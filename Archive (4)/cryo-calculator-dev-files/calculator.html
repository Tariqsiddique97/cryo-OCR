<!--
  ¬© 2025 RMC Squared Inc. All Rights Reserved.

  The Cryo Tank Calculator, including its source code, algorithms, and interface design,
  is proprietary and confidential to RMC Squared Inc. Unauthorized reproduction,
  distribution, modification, or reverse engineering of this application or its underlying
  logic is strictly prohibited and protected under U.S. and international copyright and
  trade secret laws.

  ¬© 2025 RMC Squared Inc. All Rights Reserved.
  Cryo Tank Calculator source code registered with the U.S. Copyright Office,
  Case No. 1-15021517871 (filed October 15, 2025).

  For licensed use or integration inquiries, contact chrismcbrown@gmail.com
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cryo Tank Calculator + SCF Split (Swipe)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="format-detection" content="telephone=no" />
    <style>
      :root {
        color-scheme: light dark;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        -webkit-text-size-adjust: 100%;
        background: Canvas;
        color: CanvasText;
      }

      /* Swipe container */
      .viewport {
        position: fixed;
        inset: 0;
        overflow: hidden;
      }
      .panes {
        display: flex;
        width: 400vw;
        height: 100%;
        transform: translateX(0);
        transition: transform 0.25s ease-out;
      }
      .panes[data-index="1"] {
        transform: translateX(-100vw);
      }
      .panes[data-index="2"] {
        transform: translateX(-200vw);
      }
      .panes[data-index="3"] {
        transform: translateX(-300vw);
      }
      .pane {
        width: 100vw;
        height: 100%;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
      }

      /* Enough bottom space so last inputs/buttons aren't cut off */
      .pane .page {
        padding-bottom: calc(env(safe-area-inset-bottom) + 140px);
      }
      @supports (height: 100dvh) {
        .viewport {
          height: 100dvh;
        }
      }

      /* Page padding */
      .page {
        padding: calc(env(safe-area-inset-top) + 20px) 20px calc(env(safe-area-inset-bottom) + 20px);
        max-width: 720px;
        margin: 0 auto;
      }

      /* HUD hint */
      .hint {
        position: fixed;
        left: 12px;
        right: 12px;
        bottom: 12px;
        text-align: center;
        color: #667085;
        font-size: 12px;
        opacity: 0.9;
        pointer-events: none;
        z-index: 10;
      }
      .dots {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        margin-left: 8px;
      }
      .dot {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: #cbd5e1;
        display: inline-block;
      }
      .dot.active {
        background: #22c55e;
      }
      .swipe {
        display: inline-block;
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        padding: 4px 8px;
      }

      /* Base UI */
      h1 {
        margin: 0 0 6px;
        font-weight: 700;
        font-size: 22px;
      }
      h2 {
        margin-top: 20px;
        font-size: 18px;
      }
      label {
        display: block;
        margin-top: 10px;
      }
      input,
      select,
      button {
        font-size: 16px;
        padding: 10px 12px;
        width: 100%;
        margin-top: 6px;
        box-sizing: border-box;
        border-radius: 10px;
        border: 1px solid #c9c9c9;
        background: Field;
        color: FieldText;
        -webkit-appearance: none;
        font-family: inherit;
      }
      input::placeholder {
        color: #999;
      }

      /* Buttons (blue theme) */
      button {
        cursor: pointer;
        border: none;
        background: #1a73e8;
        color: #fff;
        font-weight: 600;
        box-shadow: 0 1px 2px rgb(0 0 0 / 0.1);
        transition: filter 0.15s ease;
        width: auto;
        padding: 10px 14px;
        border-radius: 10px;
      }
      .btn-primary {
        background: #1a73e8 !important;
        color: #fff;
      }
      .btn-danger {
        background: rgb(219, 84, 84) !important;
        color: #fff;
      }
      button:disabled {
        opacity: 0.6;
      }
      button:active {
        filter: brightness(0.95);
      }
      .btn-clear {
        background: #eee;
        color: #111;
        border: 1px solid #ccc;
      }
      .btn-ghost {
        background: transparent;
        color: #1a73e8;
        border: 1px solid #cbd5e1;
      }
      .btn-adjustment {
        background: #eef2ff;
        color: #1a73e8;
        border: 1px solid #c7d2fe;
        padding: 10px 14px;
        font-size: 14px;
        font-weight: 600;
        border-radius: 999px;
        min-width: 55px;
        height: 42px;
        box-sizing: border-box;
      }
      .btn-adjustment:hover {
        background: #dbeafe;
        border-color: #99b6f9;
      }
      .btn-adjustment:active {
        filter: brightness(0.95);
      }

      .row2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .muted {
        color: #666;
        font-size: 12px;
        margin-top: 4px;
      }
      .box {
        background: #f7f7f8;
        border-radius: 12px;
        padding: 12px;
        margin-top: 12px;
      }
      .inline {
        display: inline-block;
        min-width: 140px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      }
      .result {
        margin-top: 16px;
        padding: 12px;
        background: #0000;
        border-radius: 10px;
      }
      .actions {
        display: flex;
        gap: 10px;
        margin-top: 12px;
        flex-wrap: wrap;
      }

      /* Flow Unit Toggle */
      .toggle-wrap {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 6px;
      }
      .switch {
        position: relative;
        width: 68px;
        height: 32px;
        background: #e6e6e6;
        border-radius: 999px;
        border: 1px solid #ccc;
        display: inline-block;
        cursor: pointer;
        flex-shrink: 0;
      }
      .switch input {
        display: none;
      }
      .knob {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        transition: left 0.18s ease;
      }
      .switch.on {
        background: #cfe1ff;
        border-color: #9ec2ff;
      }
      .switch.on .knob {
        left: 38px;
      }
      .unit-legend {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        font-size: 11px;
        color: #333;
        pointer-events: none;
        width: 100%;
        display: flex;
        justify-content: space-between;
        padding: 0 8px;
      }
      .unit-legend span {
        opacity: 0.7;
      }
      .switch.on .unit-legend .lb {
        font-weight: 700;
        opacity: 1;
      }
      .switch:not(.on) .unit-legend .gal {
        font-weight: 700;
        opacity: 1;
      }

      /* Split/Reserve page tweaks */
      .split h1 {
        margin: 0 0 12px;
        font-size: 20px;
        font-weight: 600;
      }
      .split .btn {
        width: auto;
      }

      /* Split/Reserve smaller fonts per client request */
      #pane-split .muted,
      #pane-reserve .muted {
        font-size: 11px;
        margin-top: 3px;
      }
      #pane-split .muted b,
      #pane-reserve .muted b {
        font-size: 13px;
        font-weight: 600;
      }
      /* Tank section styling - no box, just spacing */
      .tank-section {
        margin-top: 20px;
      }
      .tank-header {
        font-size: 14px;
        font-weight: 700;
        display: block;
        margin-bottom: 8px;
      }
      .tank-section .row2 {
        margin-bottom: 8px;
      }
      #pane-split .row2,
      #pane-reserve .row2 {
        gap: 10px;
        margin-top: 8px;
      }
      /* Split/Reserve button layout - match Tank calculator */
      #pane-split .sticky-actions,
      #pane-reserve .sticky-actions {
        gap: 10px;
        flex-wrap: wrap;
      }
      #pane-split .sticky-actions button,
      #pane-reserve .sticky-actions button {
        flex: 0 0 auto;
        width: auto;
      }
      .err {
        margin-top: 8px;
        color: #b42318;
        background: #ffefef;
        border: 1px solid #f3b3b0;
        padding: 10px;
        border-radius: 10px;
        display: none;
      }

      /* Dynamic compact mode for short screens */
      .compact .page {
        padding: 12px 14px 14px;
      }
      .compact label {
        margin-top: 3px;
      }
      .compact input,
      .compact select,
      .compact button {
        margin-top: 2px;
        padding: 8px 10px;
        font-size: 15px;
      }
      .compact .row2 {
        gap: 6px;
      }
      .compact .box {
        padding: 8px;
        margin-top: 8px;
      }
      .compact .result {
        margin-top: 10px;
        padding: 10px;
      }
      .compact .actions {
        gap: 8px;
        margin-top: 8px;
      }
      .compact h1,
      .compact .split h1 {
        margin-bottom: 4px;
        font-size: 20px;
      }
      .compact .btn {
        padding: 10px 12px;
      }

      /* Sticky action bars on Split/Reserve pages */
      #pane-split #calcSplit {
        position: sticky;
        bottom: calc(env(safe-area-inset-bottom) + 8px);
        /* width: 100%; */
        z-index: 9;
      }
      .sticky-actions {
        position: sticky;
        bottom: calc(env(safe-area-inset-bottom) + 8px);
        display: flex;
        gap: 10px;
        align-items: center;
        background: Canvas;
        padding-top: 10px;
        z-index: 9;
      }

      /* Modal */
      .modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.4);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .modal.open {
        display: flex;
      }
      .modal-card {
        width: min(560px, 94vw);
        background: Canvas;
        color: CanvasText;
        border-radius: 16px;
        padding: 16px 16px 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      }
      .modal h3 {
        margin: 0 0 6px;
        font-size: 18px;
      }
      .modal .steps {
        font-size: 14px;
        color: #555;
        margin: 8px 0 10px;
      }
      .modal .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .modal .badge {
        display: inline-block;
        background: #eef2ff;
        color: #1a73e8;
        border: 1px solid #c7d2fe;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
      }
      .modal .muted {
        color: #666;
        margin-top: 4px;
      }
      .modal .actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        justify-content: flex-end;
      }
      .pill {
        border-radius: 999px;
      }
      .dotA,
      .dotB,
      .dotC {
        color: #dc2626;
        font-weight: 700;
      }

      /* --- NEW: Photo Measure + tabs --- */
      .tabbar {
        display: flex;
        gap: 8px;
        margin: 6px 0 10px;
      }
      .tabbtn {
        padding: 6px 10px;
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #eef2ff;
        color: #0f172a;
        font-weight: 600;
        cursor: pointer;
      }
      .tabbtn.active {
        background: #1a73e8;
        color: #fff;
        border-color: #99b6f9;
      }
      .pm-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .pm-canvas-wrap {
        background: #0a0a0a;
        border-radius: 12px;
        padding: 8px;
      }
      #pmCanvas {
        display: block;
        max-width: 100%;
        border-radius: 8px;
        background: #111;
      }
      .pm-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      .pm-muted {
        font-size: 12px;
        color: #666;
        margin-top: 4px;
      }

      /* Ensure consistent field sizing for all panes */
      #pane-calc input[type="number"],
      #pane-calc input[type="text"],
      #pane-calc select,
      #pane-split input[type="number"],
      #pane-split input[type="text"],
      #pane-split select,
      #pane-reserve input[type="number"],
      #pane-reserve input[type="text"],
      #pane-reserve select {
        font-size: 16px;
        padding: 10px 12px;
      }

      /* Compact mode for Calculator pane */
      .compact #pane-calc input[type="number"],
      .compact #pane-calc input[type="text"],
      .compact #pane-calc select {
        font-size: 15px;
        padding: 8px 10px;
      }

      /* === OCR Camera Button Styles === */
      .input-with-camera {
        display: flex;
        gap: 8px;
        align-items: stretch;
        margin-top: 6px;
      }
      .input-with-camera input {
        flex: 1;
        margin: 0 !important;
        height: 44px;
        box-sizing: border-box;
      }
      .btn-camera {
        width: 44px;
        height: 44px;
        min-width: 44px;
        padding: 0;
        margin: 0;
        border-radius: 10px;
        background: #f97316;
        color: #fff;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(249, 115, 22, 0.3);
        transition: all 0.15s ease;
        flex-shrink: 0;
      }
      .btn-camera:hover {
        background: #ea580c;
        transform: scale(1.05);
      }
      .btn-camera:active {
        transform: scale(0.98);
      }
      .btn-camera svg {
        width: 22px;
        height: 22px;
      }

      /* Field with inline camera - button inside input */
      .field-with-camera {
        position: relative;
      }
      .field-with-camera input {
        width: 100%;
        padding-right: 36px !important;
        box-sizing: border-box;
      }
      /* Small camera button positioned inside input - vertically centered */
      .btn-camera-sm {
        position: absolute;
        right: 4px;
        top: 0;
        bottom: 0;
        margin: 11px 0;
        height: 28px;
        width: 28px;
        min-width: 28px;
        padding: 0;
        border-radius: 6px;
        background: #f97316;
        color: #fff;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 3px rgba(249, 115, 22, 0.3);
        transition: all 0.15s ease;
        z-index: 1;
      }
      .btn-camera-sm:hover {
        background: #ea580c;
        transform: scale(1.05);
      }
      .btn-camera-sm:active {
        transform: scale(0.98);
      }
      .btn-camera-sm svg {
        width: 14px;
        height: 14px;
      }

      /* === Cryo Reserve Calculator Field Sizing === */
      /* Tank 1-4 SCF and Remaining SCF - match Amount/Gas field width */
      #pane-reserve #resT1,
      #pane-reserve #resT2,
      #pane-reserve #resT3,
      #pane-reserve #resT4,
      #pane-reserve #resRemaining {
        width: calc(50% - 5px);
        max-width: none;
      }

      /* === Cryo Notes label line break on mobile === */
      .mobile-break { display: block; }
      @media (min-width: 480px) {
        .mobile-break { display: inline; }
      }

      /* === Split Calculator - field widths (tablet only) === */
      @media (min-width: 768px) {
        /* Total Amount row - reduce field widths */
        #pane-split #splitInput,
        #pane-split #splitInputType {
          width: 60%;
        }
        /* Gas Type - reduce width */
        #pane-split #splitGas {
          width: 60%;
        }
        /* Total SCF and Allocated SCF - half width */
        #pane-split #splitTotalSCF,
        #pane-split #t1SCF,
        #pane-split #t2SCF {
          width: calc(30% - 4px);
        }

        #pane-split #t1Full,
         #pane-split #t1Gal,
         #pane-split #t2Full,
         #pane-split #t2Gal {
          width: calc(43% - 0px);
        }
        /* Starting PSI and Ending PSI - reduce field width */
        #pane-split .tank-section .row2 .field .input-with-camera {
          max-width: 70%;
        }
      }

      /* === OCR Modal Styles - Full Screen Camera === */
      .ocr-modal {
        position: fixed;
        inset: 0;
        background: #000;
        display: none;
        flex-direction: column;
        z-index: 2000;
      }
      .ocr-modal.open {
        display: flex;
      }
      /* Full screen camera view */
      .ocr-live {
        position: absolute;
        inset: 0;
        background: #000;
      }
      .ocr-live video,
      .ocr-live canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .ocr-live .ocr-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        font-size: 16px;
      }
      /* Top bar with cancel and title */
      .ocr-topbar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        padding-top: max(16px, env(safe-area-inset-top));
        background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
        z-index: 10;
      }
      .ocr-topbar h3 {
        margin: 0;
        font-size: 18px;
        color: #fff;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .ocr-topbar .btn-close {
        background: rgba(255,255,255,0.2);
        border: none;
        color: #fff;
        font-size: 16px;
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
      }
      /* Bottom controls area */
      .ocr-bottom {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 12px 20px;
        padding-top: 12px;
        padding-bottom: calc(80px + env(safe-area-inset-bottom));
        background: rgba(0,0,0,0.92);
        z-index: 10;
        max-height: 50vh;
        overflow-y: auto;
        border-radius: 16px 16px 0 0;
      }
      /* For smaller screens, add more bottom padding */
      @media (max-height: 667px) {
        .ocr-bottom {
          padding-bottom: calc(100px + env(safe-area-inset-bottom));
        }
      }
      /* For very small screens */
      @media (max-height: 568px) {
        .ocr-bottom {
          padding-bottom: calc(120px + env(safe-area-inset-bottom));
          max-height: 45vh;
        }
      }
      .ocr-hint {
        text-align: center;
        color: rgba(255,255,255,0.8);
        font-size: 12px;
        margin-bottom: 8px;
        line-height: 1.3;
      }
      .ocr-controls {
        display: flex;
        gap: 12px;
        justify-content: center;
        margin-bottom: 8px;
      }
      .ocr-controls button {
        min-width: 100px;
      }
      /* Capture button - large circular */
      /* .ocr-capture-btn {
        width: 72px;
        height: 72px;
        border-radius: 50%;
        background: #fff;
        border: 4px solid rgba(255,255,255,0.3);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        transition: transform 0.1s;
      }
      .ocr-capture-btn:active {
        transform: scale(0.95);
      }
      .ocr-capture-btn.retake {
        background: rgba(255,255,255,0.2);
        border-color: rgba(255,255,255,0.4);
        color: #fff;
        font-size: 14px;
      } */
.ocr-capture-btn {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  background: transparent;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.12s ease, box-shadow 0.12s ease;
}

/* Inner white circle (iPhone style) */
.ocr-capture-btn::before {
  content: "";
  width: 52px;
  height: 52px;
  border-radius: 50%;
  background: #ffffff;
  transition: transform 0.12s ease, background 0.12s ease;
}

/* Press animation */
.ocr-capture-btn:active {
  transform: scale(0.94);
}

.ocr-capture-btn:active::before {
  transform: scale(0.96);
}

/* Retake / secondary state */
.ocr-capture-btn.retake {
  border-color: rgba(255, 255, 255, 0.6);
}

.ocr-capture-btn.retake::before {
  background: rgba(255, 255, 255, 0.35);
}

      /* Result overlay */
      .ocr-result {
        background: rgba(22, 163, 74, 0.95);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 8px;
        display: none;
        text-align: center;
      }
      .ocr-result.show {
        display: block;
      }
      .ocr-result.error {
        background: rgba(220, 38, 38, 0.95);
      }
      .ocr-result-label {
        font-size: 11px;
        color: rgba(255,255,255,0.8);
        margin-bottom: 3px;
      }
      .ocr-result-value {
        font-size: 28px;
        font-weight: 700;
        color: #fff;
      }
      .ocr-result.error .ocr-result-value {
        font-size: 14px;
      }
      /* Action buttons row */
      .ocr-actions {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 6px;
      }
      .ocr-actions button {
        flex: 1;
        max-width: 140px;
        padding: 10px 14px;
        font-size: 14px;
        font-weight: 600;
        border-radius: 8px;
      }
      .ocr-actions .btn-ghost {
        background: rgba(255,255,255,0.2);
        color: #fff;
        border: none;
      }
      .ocr-actions .btn-primary {
        background: #16a34a;
        color: #fff;
      }
      /* Loading overlay */
      .ocr-loading {
        display: none;
        align-items: center;
        justify-content: center;
        gap: 10px;
        padding: 20px;
        color: #fff;
      }
      .ocr-loading.show {
        display: flex;
      }
      .ocr-spinner {
        width: 24px;
        height: 24px;
        border: 3px solid rgba(255,255,255,0.3);
        border-top-color: #fff;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="viewport" id="viewport">
      <div class="panes" id="panes" data-index="0">
        <!-- === PAGE: CRYO NOTES START === -->
        <section class="pane" id="pane-notes">
          <div class="page">
            <h1>Cryo Notes</h1>
            <div class="muted">Digital field log for cryogenic transfers. Tap üì∑ on each field to capture reading via OCR, or enter values manually.</div>

            <div class="row2">
              <label>
                Select Gas:
                <select id="notesGasSelect">
                  <option value="LIN">LIN (Nitrogen)</option>
                  <option value="LOX">LOX (Oxygen)</option>
                  <option value="LAR">LAR (Argon)</option>
                  <option value="LCO2">LCO‚ÇÇ (Liquid CO‚ÇÇ)</option>
                </select>
              </label>
              <label>
                Tank ID:
                <div class="field-with-camera">
                  <input id="notesTankId" type="text" placeholder="Tank ID" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('notesTankId')" title="Capture Tank ID">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </label>
            </div>

            <div style="display: flex; gap: 4px; align-items: flex-end; overflow-x: auto;">
              <div style="flex: 1; min-width: 80px;">
                <label>Start <span class="mobile-break">Inches:</span></label>
                <div class="field-with-camera">
                  <input id="notesStartIn" type="number" inputmode="decimal" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('notesStartIn')" title="Capture Inches">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <label>Starting <span class="mobile-break">PSI:</span></label>
                <div class="field-with-camera">
                  <input id="notesStartPsi" type="number" inputmode="decimal" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('notesStartPsi')" title="Capture PSI">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <label>End <span class="mobile-break">Inches:</span></label>
                <div class="field-with-camera">
                  <input id="notesEndIn" type="number" inputmode="decimal" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('notesEndIn')" title="Capture Inches">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <label>Ending <span class="mobile-break">PSI:</span></label>
                <div class="field-with-camera">
                  <input id="notesEndPsi" type="number" inputmode="decimal" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('notesEndPsi')" title="Capture PSI">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
            </div>

            <label>
              Total Metered SCF:
              <div style="display: flex; gap: 8px; align-items: center;">
                <div class="field-with-camera" style="flex: 1;">
                  <input id="notesMeteredScf" type="number" inputmode="decimal" placeholder="Metered SCF" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('notesMeteredScf')" title="Capture Meter">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
                <select id="notesMeterScale" style="width: auto;">
                  <option value="1">x1</option>
                  <option value="10">x10</option>
                  <option value="100">x100</option>
                </select>
              </div>
              <div class="muted">SCF is 100x if stated on meter. Select the appropriate scale.</div>
            </label>

            <div class="actions">
              <button class="btn-primary" type="button" id="notesComputeBtn">Compute Summary</button>
              <button class="btn-clear" type="button" id="notesClearBtn">Clear</button>
              <button type="button" class="btn-ghost" id="notesSaveBtn">üíæ Save</button>
              <button type="button" class="btn-ghost" id="notesRecordsBtn">üìã Records</button>
              <button type="button" class="btn-primary" onclick="window.goToCalc()">Cryo Cal ‚Üí</button>
              <button id="logoutNotes" class="btn-danger" type="button">Logout</button>
            </div>

            <div class="result" id="notesSummaryBox">Summary will appear here‚Ä¶</div>

            <!-- Captured Gage Images Section with Toggle -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 24px 0 8px;">
              <h2 style="font-size: 18px; font-weight: 700; margin: 0;">Captured Gage Images</h2>
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                <span class="muted">Show</span>
                <input type="checkbox" id="notesGageToggle" checked style="display: none;">
                <span style="
                  position: relative;
                  width: 44px;
                  height: 24px;
                  background: #cbd5e1;
                  border-radius: 12px;
                  transition: background 0.2s;
                " id="notesGageToggleTrack">
                  <span style="
                    position: absolute;
                    top: 2px;
                    left: 2px;
                    width: 20px;
                    height: 20px;
                    background: #fff;
                    border-radius: 50%;
                    transition: transform 0.2s;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                  " id="notesGageToggleKnob"></span>
                </span>
              </label>
            </div>
            <div class="muted" id="notesGageDesc">Images captured using the üì∑ buttons above will appear here.</div>

            <!-- Gage Image Thumbnails -->
            <div id="notesGageThumbs" style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px;">
              <div style="flex: 1; min-width: 80px;">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px;">Start Inches</div>
                <div style="background: #000; border-radius: 8px; overflow: hidden; aspect-ratio: 4/3;">
                  <canvas id="notesThumbStartIn" style="display: block; width: 100%; height: 100%;"></canvas>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px;">Starting PSI</div>
                <div style="background: #000; border-radius: 8px; overflow: hidden; aspect-ratio: 4/3;">
                  <canvas id="notesThumbStartPsi" style="display: block; width: 100%; height: 100%;"></canvas>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px;">End Inches</div>
                <div style="background: #000; border-radius: 8px; overflow: hidden; aspect-ratio: 4/3;">
                  <canvas id="notesThumbEndIn" style="display: block; width: 100%; height: 100%;"></canvas>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px;">Ending PSI</div>
                <div style="background: #000; border-radius: 8px; overflow: hidden; aspect-ratio: 4/3;">
                  <canvas id="notesThumbEndPsi" style="display: block; width: 100%; height: 100%;"></canvas>
                </div>
              </div>
            </div>

            <!-- Unit Conversion Section -->
            <h2 style="font-size: 18px; font-weight: 700; margin: 24px 0 8px;">Unit Conversion</h2>
            <div class="muted">Convert between SCF, Gallons, and Pounds for any gas type.</div>

            <div class="row2">
              <label>
                Value:
                <input id="notesConvValue" type="number" inputmode="decimal" placeholder="Enter number" />
              </label>
              <label>
                Select Gas:
                <select id="notesConvGas">
                  <option value="LIN">LIN (Nitrogen)</option>
                  <option value="LOX">LOX (Oxygen)</option>
                  <option value="LAR">LAR (Argon)</option>
                  <option value="LCO2">LCO‚ÇÇ (Liquid CO‚ÇÇ)</option>
                </select>
              </label>
            </div>

            <div class="row2">
              <label>
                Convert FROM:
                <select id="notesFromUnit">
                  <option value="SCF">SCF</option>
                  <option value="GAL">GALLONS</option>
                  <option value="LB">POUNDS</option>
                </select>
              </label>
              <label>
                Convert TO:
                <select id="notesToUnit">
                  <option value="GAL">GALLONS</option>
                  <option value="SCF">SCF</option>
                  <option value="LB">POUNDS</option>
                </select>
              </label>
            </div>

            <div class="actions">
              <button class="btn-ghost" type="button" id="notesSwapUnitsBtn">‚áÑ Swap</button>
              <button class="btn-primary" type="button" id="notesConvertBtn">Convert</button>
              <button class="btn-clear" type="button" id="notesConvertClearBtn">Clear</button>
            </div>

            <div class="result" id="notesConvertBox">Enter a value and choose FROM/TO units‚Ä¶</div>
            <div class="muted">Uses standard published reference conversions (SCF/gal and lb/gal). Actual results can vary with conditions.</div>
          </div>
        </section>
        <!-- === PAGE: CRYO NOTES END === -->

        <!-- === PAGE: CALCULATOR START === -->
        <section class="pane" id="pane-calc">
          <div class="page">
            <h1>Cryo Tank Calculator</h1>
            <div class="muted">
              Tip: For laydown tanks,
              <b>Full Inches</b>
              means the Full Trycock inches when the tank is at ‚Äúfull.‚Äù
              <br />
              <b>Horizontal Measure</b>
              captures cylinder
              <i>diameter</i>
              and
              <i>length</i>
              only ‚Äî it does
              <b>not</b>
              measure Full Trycock height.
            </div>

            <label>
              Tank Type:
              <select id="tankType">
                <option value="vertical" selected>Vertical Tank</option>
                <option value="laydown">Laydown (Horizontal Tank)</option>
              </select>
            </label>

            <label>
              Full Inches (Full Trycock at ‚Äúfull‚Äù):
              <div style="display: flex; gap: 8px; align-items: center">
                <input id="fullInches" type="number" placeholder="0" />
                <!-- keep the same id so existing modal script still works -->
                <button id="btnMeasure" type="button" class="btn-ghost">Horizontal Measure</button>
              </div>
              <div class="muted">
                Use
                <b>Horizontal Measure</b>
                to capture cylinder size from a photo/live view. This will
                <b>not</b>
                overwrite Full Trycock inches.
              </div>
            </label>

            <!-- Geometry fields (hidden until Laydown selected) -->
            <div id="geoFields" hidden>
              <div class="row2">
                <label>
                  Tank Diameter (in)
                  <input id="geoDiameter" type="number" placeholder="e.g., 72" disabled />
                  <div class="muted">Enter manually or auto-filled from Horizontal Measure. Used for laydown geometry.</div>
                </label>
                <label>
                  Tank Length (in)
                  <input id="geoLength" type="number" placeholder="e.g., 300" disabled />
                  <div class="muted">Enter manually or auto-filled from Horizontal Measure. Informational; SCF uses Full Capacity.</div>
                </label>
              </div>
              <div id="diamHint" class="muted" hidden></div>
            </div>

            <label>
              Full Capacity:
              <div style="display: flex; gap: 6px">
                <input id="fullCap" type="number" placeholder="0" />
                <select id="capUnit">
                  <option value="scf" selected>SCF</option>
                  <option value="gal">Gallons</option>
                </select>
              </div>
              <div class="muted">Enter the tank‚Äôs rated capacity at ‚Äúfull.‚Äù</div>
            </label>

            <label>
              Select Gas:
              <select id="gas">
                <option value="LIN">LIN (Nitrogen)</option>
                <option value="LOX">LOX (Oxygen)</option>
                <option value="LAR">LAR (Argon)</option>
              </select>
            </label>

            <div style="display: flex; gap: 4px; align-items: flex-end; overflow-x: auto;">
              <div style="flex: 1; min-width: 80px;">
                <label>Start <span class="mobile-break">Inches:</span></label>
                <div class="field-with-camera">
                  <input id="startInches" type="number" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('startInches')" title="Capture Inches">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <label>Starting <span class="mobile-break">PSI:</span></label>
                <div class="field-with-camera">
                  <input id="startPsi" type="number" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('startPsi')" title="Capture PSI">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <label>End <span class="mobile-break">Inches:</span></label>
                <div class="field-with-camera">
                  <input id="endInches" type="number" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('endInches')" title="Capture Inches">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="flex: 1; min-width: 80px;">
                <label>Ending <span class="mobile-break">PSI:</span></label>
                <div class="field-with-camera">
                  <input id="endPsi" type="number" placeholder="0" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('endPsi')" title="Capture PSI">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
            </div>
            <div class="muted">
              Tap üì∑ on each field to capture reading, or enter values manually.
            </div>

            <!-- Total Formulated SCF -->
            <div style="display: flex; gap: 4px; align-items: flex-end; overflow-x: auto; margin-top: 10px;">
              <div style="flex: 2; min-width: 120px;">
                <label>Total Formulated SCF:</label>
                <div class="field-with-camera">
                  <input id="totalFormulatedScf" type="text" placeholder="Total SCF" readonly />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('totalFormulatedScf')" title="Capture Total SCF">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div style="display: flex; gap: 4px; align-items: flex-end;">
                <button type="button" class="btn-adjustment" onclick="adjustTotalScf(0.05)" title="Add 0.05% to total">+.05</button>
                <button type="button" class="btn-adjustment" onclick="adjustTotalScf(0.10)" title="Add 0.10% to total">.10</button>
              </div>
            </div>
            <div class="muted">
              Original SCF is not changed, user can add .05% or .10% to the total calculation.
            </div>

            <!-- Timer + Flow -->
            <label>
              Timer (optional):
              <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 8px; justify-content: space-between;">
                <div>
                  <button id="btnStart" type="button" class="btn-primary">Start Timer</button>
                  <button id="btnStop" type="button" class="btn-clear" disabled>Stop Timer</button>
                  <span class="inline mono" id="elapsed">Elapsed: 00:00:00</span>
                </div>
                 <div class="field-with-camera" style="min-width: 130px; max-width: 178px;">
                  <input id="meteredScf" type="number" placeholder="Metered SCF" style="font-size: 14px;" />
                  <button type="button" class="btn-camera-sm" onclick="openOcrModal('meteredScf')" title="Capture Meter">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                      <circle cx="12" cy="13" r="4"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div class="muted">Use the timer and average flow to estimate transfer. You can also estimate the tank diameter from timer data.</div>
            </label>

            <div class="row2">
              <div>
                <label>
                  Avg Flow
                  <div class="toggle-wrap">
                    <input type="number" inputmode="decimal" id="flowValue" placeholder="enter value" style="flex: 1" />
                    <div id="unitSwitch" class="switch" role="switch" aria-checked="false" tabindex="0" title="Toggle gallons ‚Üî pounds per minute">
                      <div class="unit-legend">
                        <span class="gal">gal</span>
                        <span class="lb">lb</span>
                      </div>
                      <div class="knob"></div>
                    </div>
                  </div>
                  <div class="muted">Toggle left = Gallons/min (default), right = Pounds/min.</div>
                </label>
              </div>
              <div style="display: flex; align-items: end; gap: 12px; flex-wrap: wrap">
                <label style="display: flex; gap: 8px; align-items: center">
                  <input type="checkbox" id="chkEstimateD" style="width: auto" />
                  <span>Estimate diameter from timer</span>
                </label>
                <label style="display: flex; gap: 8px; align-items: center">
                  <input type="checkbox" id="useTimerPrimary" style="width: auto" />
                  <span>Use timer as primary (ignore inches for total)</span>
                </label>
              </div>
            </div>
            <div class="muted">
              When "Use timer as primary" is on, total moved = (elapsed minutes √ó Flow) ‚Üí converted to SCF by gas. Inches still show as a cross-check.
            </div>

            <div class="actions">
              <button class="btn-primary" type="button" onclick="calculate()">Calculate</button>
              <button class="btn-clear" type="button" onclick="clearForm()">Clear</button>
              <button type="button" class="btn-ghost" onclick="saveCalculation()" id="btnSave">üíæ Save</button>
              <button type="button" class="btn-ghost" onclick="window.location.href='records.html?t=' + Date.now()" id="btnHistory">üìã Records</button>
              <button type="button" class="btn-ghost" onclick="window.goToNotes()">‚Üê Cryo Notes</button>
              <button type="button" class="btn-primary" onclick="window.goToSplit()">‚Üí Split</button>
              <button id="logoutCalc" class="btn-danger" type="button">Logout</button>
            </div>

            <div class="result" id="output">Enter values and tap Calculate.</div>
          </div>
        </section>
        <!-- === PAGE: CALCULATOR END === -->

<!-- === PAGE: SPLIT START === -->
<section class="pane" id="pane-split">
  <div class="page split">
    <h1>Cryo Split Calculator</h1>

    <!-- A) Text warning -->
    <div class="box">
      <div class="muted">
        <b>Important:</b> Only use the Split Calculator when you have the
        <b>Total SCF</b> for your truck and you are splitting that load between two tanks.
        Fill in all required fields (marked with
        <span style="color:#dc2626">*</span>) or the split will not be correct.
      </div>
    </div>

    <!-- Inline error message (shown when something is missing) -->
    <div id="splitErr" class="err" style="display:none;">
      Enter Total SCF and valid Start/End inches for both tanks before calculating.
    </div>

    <!-- Total Amount + Type -->
    <div class="row2" style="margin-top:16px;">
      <div class="field">
        <div class="muted required-label">Total Amount</div>
        <input id="splitInput" type="number" placeholder="Enter Pounds or SCF" inputmode="numeric" />
      </div>
      <div class="field">
        <div class="muted required-label">Input Type</div>
        <select id="splitInputType">
          <option value="POUNDS">Pounds (COA)</option>
          <option value="SCF">SCF</option>
        </select>
      </div>
    </div>

    <!-- Gas + Update -->
    <div class="row2" style="margin-top:8px;">
      <div class="field">
        <div class="muted">Gas Type</div>
        <select id="splitGas">
          <option value="LIN">LIN (Nitrogen)</option>
          <option value="LOX">LOX (Oxygen)</option>
          <option value="LAR">LAR (Argon)</option>
        </select>
      </div>
      <div style="display:flex;align-items:flex-end;">
        <button id="splitUpdate" type="button" class="btn-primary">Update</button>
      </div>
    </div>

    <div id="splitConverted" class="muted" style="margin-top:6px;"></div>

    <!-- Final SCF value used for split -->
    <div style="margin-top:16px;">
      <div class="muted">Total SCF</div>
      <input id="splitTotalSCF" type="text" placeholder="0" readonly />
    </div>

    <!-- Tank 1 -->
    <div class="tank-section">
      <span class="tank-header">Tank 1</span>

      <div class="row2">
        <div class="field">
          <div class="muted">Full Trycock (in)</div>
          <input id="t1Full" type="number" placeholder="0" />
        </div>
        <div class="field">
          <div class="muted">Tank Capacity (gal)</div>
          <input id="t1Gal" type="number" placeholder="0" />
        </div>
      </div>

      <div style="display: flex; gap: 4px; align-items: flex-end; overflow-x: auto;">
        <div style="flex: 1; min-width: 80px;">
          <label class="muted required-label">Start <span class="mobile-break">Inches:</span></label>
          <div class="field-with-camera">
            <input id="t1StartInches" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t1StartInches')" title="Capture Inches">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
        <div style="flex: 1; min-width: 80px;">
          <label class="muted">Starting <span class="mobile-break">PSI:</span></label>
          <div class="field-with-camera">
            <input id="t1StartPsi" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t1StartPsi')" title="Capture PSI">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
        <div style="flex: 1; min-width: 80px;">
          <label class="muted required-label">End <span class="mobile-break">Inches:</span></label>
          <div class="field-with-camera">
            <input id="t1EndInches" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t1EndInches')" title="Capture Inches">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
        <div style="flex: 1; min-width: 80px;">
          <label class="muted">Ending <span class="mobile-break">PSI:</span></label>
          <div class="field-with-camera">
            <input id="t1EndPsi" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t1EndPsi')" title="Capture PSI">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <div class="muted" style="font-size: 10px; margin-top: 4px;">Tap üì∑ on each field to capture reading, or enter manually.</div>

      <div class="field" style="margin-top:6px;">
        <div class="muted">Allocated SCF</div>
        <input id="t1SCF" type="text" placeholder="0" readonly />
      </div>
    </div>

    <!-- Tank 2 -->
    <div class="tank-section">
      <span class="tank-header">Tank 2</span>

      <div class="row2">
        <div class="field">
          <div class="muted">Full Trycock (in)</div>
          <input id="t2Full" type="number" placeholder="0" />
        </div>
        <div class="field">
          <div class="muted">Tank Capacity (gal)</div>
          <input id="t2Gal" type="number" placeholder="0" />
        </div>
      </div>

      <div style="display: flex; gap: 4px; align-items: flex-end; overflow-x: auto;">
        <div style="flex: 1; min-width: 80px;">
          <label class="muted required-label">Start <span class="mobile-break">Inches:</span></label>
          <div class="field-with-camera">
            <input id="t2StartInches" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t2StartInches')" title="Capture Inches">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
        <div style="flex: 1; min-width: 80px;">
          <label class="muted">Starting <span class="mobile-break">PSI:</span></label>
          <div class="field-with-camera">
            <input id="t2StartPsi" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t2StartPsi')" title="Capture PSI">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
        <div style="flex: 1; min-width: 80px;">
          <label class="muted required-label">End <span class="mobile-break">Inches:</span></label>
          <div class="field-with-camera">
            <input id="t2EndInches" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t2EndInches')" title="Capture Inches">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
        <div style="flex: 1; min-width: 80px;">
          <label class="muted">Ending <span class="mobile-break">PSI:</span></label>
          <div class="field-with-camera">
            <input id="t2EndPsi" type="number" placeholder="0" />
            <button type="button" class="btn-camera-sm" onclick="openOcrModal('t2EndPsi')" title="Capture PSI">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <div class="muted" style="font-size: 10px; margin-top: 4px;">Tap üì∑ on each field to capture reading, or enter manually.</div>

      <div class="field" style="margin-top:6px;">
        <div class="muted">Allocated SCF</div>
        <input id="t2SCF" type="text" placeholder="0" readonly />
      </div>
    </div>

    <!-- Buttons -->
    <div class="sticky-actions">
      <button id="splitCalc" class="btn-primary" type="button" disabled>Calculate</button>
      <button id="splitClear" class="btn-clear" type="button">Clear</button>
      <button type="button" class="btn-ghost" onclick="saveSplit()" id="btnSaveSplit">üíæ Save</button>
      <button type="button" class="btn-ghost" onclick="window.location.href='records.html?t=' + Date.now()" id="btnHistorySplit">üìã Records</button>
      <button class="btn-ghost" type="button" onclick="window.goToReserve()">‚Üí Reserve</button>
      <button id="logoutSplit" class="btn-danger" type="button">Logout</button>
    </div>
  </div>
</section>
<!-- === PAGE: SPLIT END === -->

<!-- === PAGE: RESERVE START === -->
<section class="pane" id="pane-reserve">
  <div class="page split">
    <h1>Cryo Reserve Calculator</h1>

    <!-- INPUT AMOUNT + TYPE -->
    <div class="row2" style="margin-top:12px;">
      <div>
        <div class="muted">Amount</div>
        <input id="resAmount" type="number" placeholder="Enter Pounds or SCF" inputmode="numeric" />
      </div>

      <div>
        <div class="muted">Input Type</div>
        <select id="resInputType">
          <option value="POUNDS">Pounds (COA)</option>
          <option value="SCF">SCF</option>
        </select>
      </div>
    </div>

    <!-- GAS + UPDATE -->
    <div class="row2" style="margin-top:10px;">
      <div>
        <div class="muted">Gas</div>
        <select id="resGas">
          <option value="LIN">LIN (Nitrogen)</option>
          <option value="LOX">LOX (Oxygen)</option>
          <option value="LAR">LAR (Argon)</option>
        </select>
      </div>

      <div style="display:flex; align-items:flex-end;">
        <button id="resUpdate" type="button" class="btn-primary">Update</button>
      </div>
    </div>

    <div id="resHint" class="muted" style="margin-top:6px;"></div>

    <!-- TANK INPUTS -->
    <div style="margin-top:16px;">
      <div class="muted"><b>Tank 1 SCF</b></div>
      <input id="resT1" type="number" placeholder="0" />
    </div>

    <div style="margin-top:12px;">
      <div class="muted"><b>Tank 2 SCF</b></div>
      <input id="resT2" type="number" placeholder="0" />
    </div>

    <div style="margin-top:12px;">
      <div class="muted"><b>Tank 3 SCF</b></div>
      <input id="resT3" type="number" placeholder="0" />
    </div>

    <div style="margin-top:12px;">
      <div class="muted"><b>Tank 4 SCF</b></div>
      <input id="resT4" type="number" placeholder="0" />
    </div>

    <!-- REMAINING -->
    <div style="margin-top:16px;">
      <div class="muted"><b>Remaining SCF</b></div>
      <input id="resRemaining" type="text" placeholder="0" readonly />
    </div>

    <div class="sticky-actions">
      <button id="resClear" class="btn-primary" type="button">Clear</button>
      <button type="button" class="btn-ghost" onclick="saveReserve()" id="btnSaveReserve">üíæ Save</button>
      <button type="button" class="btn-ghost" onclick="window.location.href='records.html?t=' + Date.now()" id="btnHistoryReserve">üìã Records</button>
      <button class="btn-ghost" type="button" onclick="window.goToNotes()">‚Üê Home</button>
      <button id="logout" class="btn-danger" type="button" >Logout</button>
    </div>
  </div>
</section>
<!-- === PAGE: RESERVE END === -->

<!-- === RESERVE SCRIPT START === -->
<script>
(function () {

  const gas = {
    LIN: { scfPerLb: 13.8 },
    LOX: { scfPerLb: 12.1 },
    LAR: { scfPerLb: 9.57 }
  };

  const $ = sel => {
    if (!sel) return null;
    return document.getElementById(sel[0] === "#" ? sel.slice(1) : sel);
  };
  const num = v => Number(v) || 0;

  let totalSCF = 0;

  /* -------------------------------------------
     UPDATE BUTTON ‚Üí SCF stays the same / Pounds ‚Üí SCF
  -------------------------------------------- */
  const updateBtn = $("#resUpdate");
  if (updateBtn) {
    updateBtn.addEventListener("click", () => {
      const rawStr = ($("#resAmount").value || "").trim();
      const type   = $("#resInputType").value;
      const gasKey = $("#resGas").value;
      const g      = gas[gasKey];

      if (!rawStr) {
        totalSCF = 0;
        writeTotals();
        return;
      }

      const amt = Number(rawStr);
      if (!Number.isFinite(amt) || amt <= 0) {
        totalSCF = 0;
        writeTotals();
        return;
      }

      if (type === "SCF") {
        totalSCF = Math.min(999999, Math.round(amt));
      } else {
        if (!g) {
          totalSCF = 0;
          writeTotals();
          return;
        }
        totalSCF = Math.min(999999, Math.round(amt * g.scfPerLb));
      }

      writeTotals();
    });
  }

  /* -------------------------------------------
     Write Totals (Hint + Remaining SCF)
  -------------------------------------------- */
  function writeTotals() {
    const display = totalSCF > 0 ? totalSCF.toLocaleString() : "0";

    $("#resRemaining").value = display;
    $("#resHint").textContent = totalSCF > 0
      ? `Total SCF available: ${display}`
      : "";

    recalcRemaining();
  }

  /* -------------------------------------------
     Recalculate Remaining SCF
  -------------------------------------------- */
  function recalcRemaining() {
    const used =
      num($("#resT1").value) +
      num($("#resT2").value) +
      num($("#resT3").value) +
      num($("#resT4").value);

    const remain = Math.max(0, totalSCF - used);
    $("#resRemaining").value = remain.toLocaleString();
  }

  ["resT1","resT2","resT3","resT4"].forEach(id => {
    const el = $(id);
    if (el) el.addEventListener("input", recalcRemaining);
  });

  /* -------------------------------------------
     CLEAR FIELDS (now fully working)
  -------------------------------------------- */
  const clearBtn = $("#resClear");
  if (clearBtn) {
    clearBtn.addEventListener("click", () => {
      ["resAmount","resT1","resT2","resT3","resT4","resRemaining"]
        .forEach(id => {
          const el = $(id);
          if (el) el.value = "";
        });

      $("#resHint").textContent = "";
      totalSCF = 0;

      // Clear localStorage for reserve calculator
      localStorage.removeItem("reserveCalculatorData");
    });
  }

  /* -------------------------------------------
     SESSION STORAGE: Reserve Calculator
  -------------------------------------------- */
  const reserveFields = [
    "resAmount", "resInputType", "resGas",
    "resT1", "resT2", "resT3", "resT4", "resRemaining"
  ];

  function saveReserveToSession() {
    const data = {};
    reserveFields.forEach(id => {
      const el = $(id);
      if (el) data[id] = el.value;
    });
    data.totalSCF = totalSCF; // Save the totalSCF variable
    data.resHint = $("#resHint")?.textContent || "";
    localStorage.setItem("reserveCalculatorData", JSON.stringify(data));
  }

  function loadReserveFromSession() {
    const saved = localStorage.getItem("reserveCalculatorData");
    if (!saved) return;

    try {
      const data = JSON.parse(saved);
      reserveFields.forEach(id => {
        const el = $(id);
        if (el && data[id] !== undefined && data[id] !== "") {
          el.value = data[id];
        }
      });
      if (data.totalSCF !== undefined) totalSCF = data.totalSCF;
      if (data.resHint) $("#resHint").textContent = data.resHint;
    } catch (e) {
      console.error("Error loading reserve data:", e);
    }
  }

  function setupReserveAutoSave() {
    reserveFields.forEach(id => {
      const el = $(id);
      if (el) {
        el.addEventListener("input", saveReserveToSession);
        el.addEventListener("change", saveReserveToSession);
      }
    });
  }

  // Load and setup auto-save for reserve calculator
  loadReserveFromSession();
  setupReserveAutoSave();

})();
</script>
<!-- === RESERVE SCRIPT END === -->


      <div class="hint">
        <span class="swipe">Swipe left/right</span>
        <span class="dots">
          <span class="dot active" id="d0"></span>
          <span class="dot" id="d1"></span>
          <span class="dot" id="d2"></span>
          <span class="dot" id="d3"></span>
        </span>
      </div>
    </div>

    <!-- === PAGE: MEASURE MODAL START === -->
    <style>
      /* Modal shell */
      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.45);
        z-index: 1000;
      }
      .modal.open {
        display: flex;
      }
      .hm-card {
        width: min(640px, 96vw);
        max-height: 92vh;
        overflow: auto;
        background: Canvas;
        color: CanvasText;
        border-radius: 16px;
        padding: 14px 14px 10px;
        box-shadow: 0 12px 28px rgba(0, 0, 0, 0.28);
        /* Hide scrollbar but keep scroll functionality */
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE/Edge */
      }
      .hm-card::-webkit-scrollbar {
        display: none; /* Chrome/Safari/Opera */
      }
      .hm-h1 {
        margin: 0 0 8px;
        font-size: 18px;
        font-weight: 700;
      }

      /* Tabs + buttons */
      .hm-tabs {
        display: flex;
        gap: 8px;
        margin: 6px 0 8px;
      }
      .hm-tab {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid #cbd5e1;
        background: #eef2ff;
        font-weight: 600;
        cursor: pointer;
      }
      .hm-tab.active {
        background: #1a73e8;
        color: #fff;
        border-color: #99b6f9;
      }
      .btn {
        border: none;
        border-radius: 10px;
        padding: 10px 14px;
        font-weight: 600;
        background: #1a73e8;
        color: #fff;
        cursor: pointer;
      }
      .btn-ghost {
        background: transparent;
        color: #1a73e8;
        border: 1px solid #cbd5e1;
      }
      .btn-clear {
        background: #f4f4f5;
        color: #111;
        border: 1px solid #d1d5db;
      }

      /* Live stage */
      .hm-live {
        position: relative;
        width: 100%;
        aspect-ratio: 4/3;
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        background: #000;
        overflow: hidden;
      }
      #hmVideo,
      #hmCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }

      .hm-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      .hm-muted {
        font-size: 12px;
        color: #666;
      }
      .hm-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        border-top: 1px solid #e5e7eb;
        margin-top: 12px;
        padding-top: 10px;
      }

      /* Thumbnails */
      .hm-thumbs {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 12px;
      }
      .hm-thumb {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        overflow: hidden;
        background: #000;
      }
      .hm-thumb canvas {
        display: block;
        width: 100%;
        height: auto;
      }
      .hm-cap {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        margin-top: 6px;
      }
    </style>

    <div id="measureModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="hmTitle">
      <div class="hm-card">
        <h3 id="hmTitle" class="hm-h1">Horizontal Tank Tool</h3>

        <!-- Diameter / Length capture -->
        <div class="hm-tabs">
          <button id="hmTabD" class="hm-tab active" type="button">Diameter</button>
          <button id="hmTabL" class="hm-tab" type="button">Length</button>
          <span class="hm-muted" style="margin-left: auto">Tap‚Äìdrag on the image to draw the red line.</span>
        </div>

        <!-- Live camera + overlay -->
        <div class="hm-live">
          <video id="hmVideo" playsinline></video>
          <canvas id="hmCanvas"></canvas>
        </div>

        <!-- Controls row: Known length, Capture, Retake, Ruler, Full Measure -->
        <div class="hm-row" style="gap: 8px; justify-content: space-around; align-items: center; margin-top: 8px; flex-wrap: wrap">
          <span class="hm-muted" style="font-size: 11px">Known length (in)</span>
          <input
            id="hmRefIn"
            type="number"
            inputmode="decimal"
            placeholder="12"
            min="1"
            style="width: 60px; padding: 8px; border-radius: 8px; border: 1px solid #cbd5e1; background: Field; color: FieldText; text-align: center"
          />
          <button id="hmCapture" class="btn" type="button" style="padding: 8px 12px; font-size: 13px">üì∑ Capture</button>
          <button id="hmRetake" class="btn-ghost" type="button" style="padding: 8px 12px; font-size: 13px">Retake</button>
          <span style="width: 16px"></span>
          <button
            id="hmModeRuler"
            type="button"
            style="
              width: 52px;
              height: 52px;
              border-radius: 50%;
              border: 3px solid #22c55e;
              background: #dcfce7;
              color: #166534;
              font-weight: 600;
              font-size: 9px;
              cursor: pointer;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              gap: 1px;
            "
          >
            <span>Ruler</span>
          </button>
          <button
            id="hmModeMeasure"
            type="button"
            style="
              width: 52px;
              height: 52px;
              border-radius: 50%;
              border: 3px solid #ef4444;
              background: #fee2e2;
              color: #991b1b;
              font-weight: 600;
              font-size: 9px;
              cursor: pointer;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              gap: 1px;
            "
          >
            <span>Full Measure</span>
          </button>
        </div>
        <span id="hmNote" class="hm-muted">
          Scroll to zoom, right-click drag to pan. Capture image, draw lines with Ruler and Measure buttons, then Apply.
        </span>

        <!-- Measurement Result Fields -->
        <div class="hm-row" style="margin-top: 12px">
          <div style="display: flex; gap: 12px; align-items: center; flex: 1">
            <div style="flex: 1">
              <label class="hm-muted" style="display: block; margin-bottom: 4px">Diameter (in)</label>
              <input
                id="hmCalculatedDiameter"
                type="number"
                inputmode="decimal"
                readonly
                placeholder="e.g. 120"
                aria-readonly="true"
                style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #cbd5e1; background: #fff; color: #666"
              />
            </div>
            <div style="flex: 1">
              <label class="hm-muted" style="display: block; margin-bottom: 4px">Length (in)</label>
              <input
                id="hmCalculatedLength"
                type="number"
                inputmode="decimal"
                readonly
                placeholder="e.g. 1500"
                aria-readonly="true"
                style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #cbd5e1; background: #fff; color: #666"
              />
            </div>
          </div>
          <button id="hmApply" class="btn" type="button" style="align-self: flex-end; padding: 10px 20px">Apply</button>
        </div>

        <!-- Thumbnails with measured result labels -->
        <div class="hm-thumbs">
          <div>
            <div class="hm-cap">
              <b>Diameter Image</b>
              <span class="hm-muted" id="hmValD"></span>
            </div>
            <div class="hm-thumb"><canvas id="hmThumbD"></canvas></div>
          </div>
          <div>
            <div class="hm-cap">
              <b>Length Image</b>
              <span class="hm-muted" id="hmValL"></span>
            </div>
            <div class="hm-thumb"><canvas id="hmThumbL"></canvas></div>
          </div>
        </div>

        <div class="hm-actions">
          <button id="hmClose" class="btn-ghost" type="button">Close</button>
        </div>
      </div>
    </div>
    <!-- === PAGE: MEASURE MODAL END === -->

    <!-- === OCR PSI CAPTURE MODAL START === -->
    <div id="ocrModal" class="ocr-modal" role="dialog" aria-modal="true" aria-labelledby="ocrTitle">
      <!-- Full Screen Camera View -->
      <div class="ocr-live">
        <video id="ocrVideo" playsinline autoplay muted></video>
        <canvas id="ocrCanvas" style="display: none;"></canvas>
        <div class="ocr-placeholder" id="ocrPlaceholder">Starting camera...</div>
      </div>

      <!-- Top Bar -->
      <div class="ocr-topbar">
        <h3 id="ocrTitle">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
            <circle cx="12" cy="13" r="4"/>
          </svg>
          Capture Reading
        </h3>
        <button id="ocrCancel" type="button" class="btn-close">‚úï Close</button>
      </div>

      <!-- Bottom Controls -->
      <div class="ocr-bottom">
        <p class="ocr-hint">Point camera at gauge and tap the button to capture</p>

        <!-- Loading State -->
        <div id="ocrLoading" class="ocr-loading">
          <div class="ocr-spinner"></div>
          <span>Reading value...</span>
        </div>

        <!-- Result Display -->
        <div id="ocrResult" class="ocr-result">
          <div class="ocr-result-label">Detected Value:</div>
          <div class="ocr-result-value" id="ocrResultValue">--</div>
        </div>

        <!-- Capture/Retake Controls -->
        <div class="ocr-controls">
          <button id="ocrCapture" type="button" class="ocr-capture-btn" title="Capture"></button>
          <button id="ocrRetake" type="button" class="ocr-capture-btn retake" style="display: none;">‚Ü∫ Retake</button>
        </div>

        <!-- Actions (shown after capture) -->
        <div class="ocr-actions" id="ocrActions" style="display: none;">
          <button id="ocrRetakeAlt" type="button" class="btn-ghost">Retake</button>
          <button id="ocrApply" type="button" class="btn-primary" disabled>Apply Value</button>
        </div>
      </div>
    </div>
    <!-- === OCR PSI CAPTURE MODAL END === -->

    <!-- === SCRIPTS: MEASURE MODAL START === -->
    <script>
      (function () {
        // External fields to populate
        const geoDiameter = document.getElementById("geoDiameter");
        const geoLength = document.getElementById("geoLength");
        const geoFields = document.getElementById("geoFields");
        const showGeo = () => {
          if (geoFields) geoFields.hidden = false;
          if (geoDiameter) geoDiameter.disabled = false;
          if (geoLength) geoLength.disabled = false;
        };
        const putVal = (el, v) => {
          if (!el || !isFinite(v)) return;
          el.value = Math.round(v);
          el.dispatchEvent(new Event("input", { bubbles: true }));
          el.dispatchEvent(new Event("change", { bubbles: true }));
        };

        // Modal + UI
        const modal = document.getElementById("measureModal");
        const tabD = document.getElementById("hmTabD");
        const tabL = document.getElementById("hmTabL");
        const note = document.getElementById("hmNote");
        const refIn = document.getElementById("hmRefIn");
        const btnClose = document.getElementById("hmClose");
        const btnCapture = document.getElementById("hmCapture");
        const btnRetake = document.getElementById("hmRetake");
        const btnApply = document.getElementById("hmApply");
        const btnModeRuler = document.getElementById("hmModeRuler");
        const btnModeMeasure = document.getElementById("hmModeMeasure");
        const calculatedDiameter = document.getElementById("hmCalculatedDiameter");
        const calculatedLength = document.getElementById("hmCalculatedLength");

        // Live + drawing
        const video = document.getElementById("hmVideo");
        const canvas = document.getElementById("hmCanvas");
        const ctx = canvas.getContext("2d");

        // Thumbs
        const cThumbD = document.getElementById("hmThumbD");
        const cThumbL = document.getElementById("hmThumbL");
        const vD = document.getElementById("hmValD");
        const vL = document.getElementById("hmValL");

        // State
        let mode = "D"; // 'D' or 'L' - which dimension to measure
        let stream = null;
        let still = null; // Image of last captured frame
        let rulerLine = null; // Calibration line (in IMAGE coordinates)
        let measurementLine = null; // Actual measurement line (in IMAGE coordinates)
        let line = null; // Current line being drawn
        let drawing = false;
        let pxPerInch = null;
        let measuredD = null,
          measuredL = null;
        let drawMode = "ruler"; // 'ruler' or 'measurement'

        // Zoom & Pan state
        let scale = 1.0; // Zoom level
        let offsetX = 0; // Pan X
        let offsetY = 0; // Pan Y
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastTouchDistance = 0;

        // Image dimensions after drawContain
        let imgDrawWidth = 0;
        let imgDrawHeight = 0;
        let imgDrawX = 0;
        let imgDrawY = 0;

        // Animation loop for live video
        let animationId = null;

        function startVideoLoop() {
          if (animationId) return; // Already running
          function loop() {
            if (!still && stream && video.videoWidth) {
              draw();
            }
            animationId = requestAnimationFrame(loop);
          }
          animationId = requestAnimationFrame(loop);
        }

        function stopVideoLoop() {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
        }

        // Camera
        async function openCam() {
          try {
            stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: "environment" } }, audio: false });
            video.srcObject = stream;
            await video.play();
            fitAndDraw();
            startVideoLoop();
          } catch (e) {
            alert("Camera error: " + e.message);
          }
        }
        function closeCam() {
          if (stream) {
            stream.getTracks().forEach((t) => t.stop());
            stream = null;
          }
          try {
            video.pause();
          } catch (_) {}
          video.removeAttribute("srcObject");
        }

        // Layout / drawing
        function fitAndDraw() {
          const box = canvas.parentElement.getBoundingClientRect();
          canvas.width = box.width;
          canvas.height = box.height;
          draw();
        }

        function draw() {
          if (!ctx) return;
          const w = canvas.width,
            h = canvas.height;

          // Clear and reset transform
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, w, h);

          // Draw the still image or live video
          if (still && still.complete) {
            const imgToShow = still;
            // Hide video when showing still image
            if (video) video.style.opacity = "0";

            // Fill background with black
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, w, h);

            // Calculate contained image dimensions
            const s = Math.min(w / imgToShow.naturalWidth, h / imgToShow.naturalHeight);
            const imgW = imgToShow.naturalWidth * s;
            const imgH = imgToShow.naturalHeight * s;

            // Store for pan constraints
            imgDrawWidth = imgW;
            imgDrawHeight = imgH;

            // Apply transform: translate to center, scale, pan, then offset to top-left
            ctx.save();

            // Move origin to center of canvas
            ctx.translate(w / 2, h / 2);

            // Apply scale
            ctx.scale(scale, scale);

            // Apply pan offset (in scaled space)
            ctx.translate(offsetX / scale, offsetY / scale);

            // Move to top-left corner of where image should be drawn (centered)
            ctx.translate(-imgW / 2, -imgH / 2);

            // Draw image at origin
            ctx.drawImage(imgToShow, 0, 0, imgW, imgH);

            ctx.restore();

            // Draw lines in same transformed space
            ctx.save();

            // Same transform sequence
            ctx.translate(w / 2, h / 2);
            ctx.scale(scale, scale);
            ctx.translate(offsetX / scale, offsetY / scale);
            ctx.translate(-imgW / 2, -imgH / 2);

            // Draw ruler line (green) if exists
            if (rulerLine) {
              ctx.lineWidth = 2 / scale;
              ctx.strokeStyle = "#22c55e"; // Green for ruler calibration
              ctx.lineCap = "round";
              ctx.beginPath();
              ctx.moveTo(rulerLine.x1, rulerLine.y1);
              ctx.lineTo(rulerLine.x2, rulerLine.y2);
              ctx.stroke();
            }

            // Draw measurement line (red) if exists
            if (measurementLine) {
              ctx.lineWidth = 2 / scale;
              ctx.strokeStyle = "#ef4444"; // Red for measurement
              ctx.lineCap = "round";
              ctx.beginPath();
              ctx.moveTo(measurementLine.x1, measurementLine.y1);
              ctx.lineTo(measurementLine.x2, measurementLine.y2);
              ctx.stroke();
            }

            // Draw current line being drawn
            if (line) {
              ctx.lineWidth = 2 / scale;
              ctx.strokeStyle = drawMode === "ruler" ? "#22c55e" : "#ef4444"; // Green for ruler, Red for measurement
              ctx.lineCap = "round";
              ctx.beginPath();
              ctx.moveTo(line.x1, line.y1);
              ctx.lineTo(line.x2, line.y2);
              ctx.stroke();
            }

            ctx.restore();
          } else if (video && video.videoWidth) {
            // Show video when no still image
            if (video) video.style.opacity = "1";
            ctx.drawImage(video, 0, 0, w, h);
          } else {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, w, h);
          }

          // Update zoom level display
          updateZoomDisplay();
        }

        function drawContain(img, ctx, cw, ch) {
          const s = Math.min(cw / img.naturalWidth, ch / img.naturalHeight);
          const dw = img.naturalWidth * s,
            dh = img.naturalHeight * s;
          const dx = (cw - dw) / 2,
            dy = (ch - dh) / 2;

          // Store these for pan constraints
          imgDrawWidth = dw;
          imgDrawHeight = dh;
          imgDrawX = dx;
          imgDrawY = dy;

          ctx.drawImage(img, dx, dy, dw, dh);
        }

        function captureStill() {
          if (!video.videoWidth) return false;
          const tmp = document.createElement("canvas");
          tmp.width = video.videoWidth;
          tmp.height = video.videoHeight;
          const tmpCtx = tmp.getContext("2d");
          tmpCtx.drawImage(video, 0, 0);
          const img = new Image();
          img.onload = () => {
            still = img;
            resetZoom();
            fitAndDraw();
            updateUI();
          };
          img.src = tmp.toDataURL("image/png");
          return true;
        }

        // Zoom functions
        function resetZoom() {
          scale = 1.0;
          offsetX = 0;
          offsetY = 0;
        }

        function zoom(delta, centerX, centerY) {
          const oldScale = scale;
          scale = Math.max(1.0, Math.min(5.0, scale * delta));

          // Adjust offset to zoom towards center point
          if (centerX !== undefined && centerY !== undefined) {
            offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
            offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
          }

          constrainPan();
          draw();
        }

        function constrainPan() {
          if (scale <= 1.0) {
            offsetX = 0;
            offsetY = 0;
            return;
          }

          // Calculate how much the scaled image exceeds canvas bounds
          const scaledWidth = imgDrawWidth * scale;
          const scaledHeight = imgDrawHeight * scale;

          // How much has the image grown beyond its original contained size
          const excessWidth = scaledWidth - imgDrawWidth;
          const excessHeight = scaledHeight - imgDrawHeight;

          // Max pan is half the excess (we can pan left/right by this much)
          const maxOffsetX = excessWidth / 2;
          const maxOffsetY = excessHeight / 2;

          // Constrain the offsets
          offsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, offsetX));
          offsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, offsetY));
        }

        function updateZoomDisplay() {
          // Zoom level display removed - function kept for compatibility
        }

        // Convert screen coordinates to image coordinates
        function screenToImage(screenX, screenY) {
          const rect = canvas.getBoundingClientRect();
          const canvasX = screenX - rect.left;
          const canvasY = screenY - rect.top;

          const w = canvas.width;
          const h = canvas.height;

          // Reverse the transform sequence:
          // 1. Subtract canvas center
          let x = canvasX - w / 2;
          let y = canvasY - h / 2;

          // 2. Reverse scale
          x = x / scale;
          y = y / scale;

          // 3. Reverse pan
          x = x - offsetX / scale;
          y = y - offsetY / scale;

          // 4. Reverse image centering (add back half image size)
          x = x + imgDrawWidth / 2;
          y = y + imgDrawHeight / 2;

          return { x: x, y: y };
        }

        // Pointer events for drawing lines
        function getPointerPos(e) {
          const t = "touches" in e ? e.touches[0] : e;
          return screenToImage(t.clientX, t.clientY);
        }

        // Prevent context menu on canvas for right-click pan
        canvas.addEventListener("contextmenu", (e) => {
          e.preventDefault();
        });

        // Mouse events - left click to draw, right click to pan
        canvas.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
            // Right click - pan
            e.preventDefault();
            isPanning = true;
            panStartX = e.clientX - offsetX;
            panStartY = e.clientY - offsetY;
            canvas.style.cursor = "grabbing";
          } else if (e.button === 0) {
            // Left click - draw (only when image is captured)
            if (!still) return;
            drawing = true;
            const p = getPointerPos(e);
            line = { x1: p.x, y1: p.y, x2: p.x, y2: p.y };
            draw();
          }
        });

        canvas.addEventListener("mousemove", (e) => {
          if (isPanning) {
            offsetX = e.clientX - panStartX;
            offsetY = e.clientY - panStartY;
            constrainPan();
            draw();
          } else if (drawing) {
            const p = getPointerPos(e);
            line.x2 = p.x;
            line.y2 = p.y;
            draw();
          }
        });

        window.addEventListener("mouseup", () => {
          if (drawing && line) {
            // Save the completed line based on current draw mode
            if (drawMode === "ruler") {
              rulerLine = { ...line };
            } else {
              measurementLine = { ...line };
            }
            autoCalculate();
            draw();
          }
          drawing = false;
          isPanning = false;
          canvas.style.cursor = still ? "crosshair" : "default";
        });

        // Update cursor for drawing
        canvas.addEventListener("mouseenter", () => {
          canvas.style.cursor = "crosshair";
        });

        // Mouse wheel for zoom
        canvas.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom(delta, e.offsetX, e.offsetY);
          },
          { passive: false }
        );

        // Touch events for drawing and pinch-zoom
        let touchMode = null; // 'draw', 'pan', or 'pinch'

        canvas.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 1) {
              // Single touch - only draw when image is captured
              if (!still) return; // Don't draw on live video
              touchMode = "draw";
              drawing = true;
              const p = getPointerPos(e);
              line = { x1: p.x, y1: p.y, x2: p.x, y2: p.y };
              draw();
            } else if (e.touches.length === 2) {
              // Two fingers - pinch zoom
              touchMode = "pinch";
              drawing = false;
              isPanning = false;
              const dx = e.touches[1].clientX - e.touches[0].clientX;
              const dy = e.touches[1].clientY - e.touches[0].clientY;
              lastTouchDistance = Math.hypot(dx, dy);
            }
          },
          { passive: true }
        );

        canvas.addEventListener(
          "touchmove",
          (e) => {
            if (touchMode === "draw" && e.touches.length === 1) {
              const p = getPointerPos(e);
              line.x2 = p.x;
              line.y2 = p.y;
              draw();
            } else if (e.touches.length === 2) {
              // Pinch zoom
              touchMode = "pinch";
              drawing = false;

              const dx = e.touches[1].clientX - e.touches[0].clientX;
              const dy = e.touches[1].clientY - e.touches[0].clientY;
              const distance = Math.hypot(dx, dy);

              if (lastTouchDistance > 0) {
                const delta = distance / lastTouchDistance;
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                const rect = canvas.getBoundingClientRect();
                zoom(delta, centerX - rect.left, centerY - rect.top);
              }

              lastTouchDistance = distance;
            } else if (e.touches.length === 1 && touchMode === "pinch") {
              // After pinch, switch to pan
              touchMode = "pan";
              const touch = e.touches[0];
              panStartX = touch.clientX - offsetX;
              panStartY = touch.clientY - offsetY;
            } else if (touchMode === "pan" && e.touches.length === 1) {
              const touch = e.touches[0];
              offsetX = touch.clientX - panStartX;
              offsetY = touch.clientY - panStartY;
              constrainPan();
              draw();
            }
          },
          { passive: true }
        );

        canvas.addEventListener(
          "touchend",
          (e) => {
            if (e.touches.length === 0) {
              if (drawing && line && touchMode === "draw") {
                // Save the completed line based on current draw mode
                if (drawMode === "ruler") {
                  rulerLine = { ...line };
                } else {
                  measurementLine = { ...line };
                }
                autoCalculate();
                draw();
              }
              drawing = false;
              isPanning = false;
              touchMode = null;
              lastTouchDistance = 0;
            } else if (e.touches.length === 1 && touchMode === "pinch") {
              // Transition from pinch to pan
              touchMode = "pan";
              const touch = e.touches[0];
              panStartX = touch.clientX - offsetX;
              panStartY = touch.clientY - offsetY;
            }
          },
          { passive: true }
        );

        function linePixels() {
          if (!line) return 0;
          return Math.hypot(line.x2 - line.x1, line.y2 - line.y1);
        }

        // Thumbs
        function paintThumb(dstCanvas, img, lineObj, label, lineColor, refLineObj) {
          if (!dstCanvas || !img) return;
          const w = (dstCanvas.width = Math.min(640, dstCanvas.parentElement.clientWidth));
          const h = (dstCanvas.height = Math.round((w * 3) / 4));
          const tctx = dstCanvas.getContext("2d");
          tctx.clearRect(0, 0, w, h);
          drawContain(img, tctx, w, h);

          // Calculate scale for thumbnail
          const imgScale = Math.min(w / img.naturalWidth, h / img.naturalHeight);
          const dw = img.naturalWidth * imgScale;
          const dh = img.naturalHeight * imgScale;
          const dx = (w - dw) / 2;
          const dy = (h - dh) / 2;

          // Draw reference line (green) if provided
          if (refLineObj) {
            const tx1 = refLineObj.x1 * imgScale + dx;
            const ty1 = refLineObj.y1 * imgScale + dy;
            const tx2 = refLineObj.x2 * imgScale + dx;
            const ty2 = refLineObj.y2 * imgScale + dy;

            tctx.lineWidth = 2;
            tctx.strokeStyle = "#22c55e"; // Green for reference line
            tctx.lineCap = "round";
            tctx.beginPath();
            tctx.moveTo(tx1, ty1);
            tctx.lineTo(tx2, ty2);
            tctx.stroke();
          }

          // Draw measurement line if provided
          if (lineObj) {
            const tx1 = lineObj.x1 * imgScale + dx;
            const ty1 = lineObj.y1 * imgScale + dy;
            const tx2 = lineObj.x2 * imgScale + dx;
            const ty2 = lineObj.y2 * imgScale + dy;

            tctx.lineWidth = 2;
            tctx.strokeStyle = lineColor || "#ef4444"; // Use provided color or default to red
            tctx.lineCap = "round";
            tctx.beginPath();
            tctx.moveTo(tx1, ty1);
            tctx.lineTo(tx2, ty2);
            tctx.stroke();
          }
          if (label) {
            tctx.fillStyle = "rgba(0,0,0,.55)";
            tctx.fillRect(8, 8, 170, 28);
            tctx.fillStyle = "#fff";
            tctx.font = "bold 14px system-ui, -apple-system, Segoe UI, Roboto";
            tctx.fillText(label, 16, 28);
          }
        }

        // Update UI for current draw mode
        function updateUI() {
          // Update button styles based on current draw mode
          if (drawMode === "ruler") {
            btnModeRuler.style.boxShadow = "0 0 0 4px rgba(34, 197, 94, 0.5)";
            btnModeMeasure.style.boxShadow = "none";
          } else {
            btnModeRuler.style.boxShadow = "none";
            btnModeMeasure.style.boxShadow = "0 0 0 4px rgba(239, 68, 68, 0.5)";
          }

          if (!still) {
            // No image captured yet - show live video
            note.textContent = "Position camera, then press Capture.";
          } else if (drawMode === "ruler") {
            note.textContent = "Draw green line over ruler, enter known inches.";
          } else {
            note.textContent = `Draw red line for full ${mode === "D" ? "diameter" : "length"}.`;
          }
        }

        // Update calculations automatically
        function autoCalculate() {
          // Calculate pxPerInch from ruler line
          if (rulerLine) {
            const rulerPx = Math.hypot(rulerLine.x2 - rulerLine.x1, rulerLine.y2 - rulerLine.y1);
            const ref = parseFloat(refIn.value);
            if (isFinite(ref) && ref > 0 && rulerPx > 10) {
              pxPerInch = rulerPx / ref;
            }
          }

          // Calculate measurement from measurement line
          if (measurementLine && pxPerInch) {
            const measurePx = Math.hypot(measurementLine.x2 - measurementLine.x1, measurementLine.y2 - measurementLine.y1);
            const inches = measurePx / pxPerInch;

            if (mode === "D") {
              measuredD = inches;
              if (calculatedDiameter) calculatedDiameter.value = inches.toFixed(0);
              // Update thumbnail
              paintThumb(cThumbD, still, measurementLine, `‚âà ${inches.toFixed(0)} in`, "#ef4444", rulerLine);
              if (vD) vD.textContent = `${inches.toFixed(0)} in`;
            } else {
              measuredL = inches;
              if (calculatedLength) calculatedLength.value = inches.toFixed(0);
              // Update thumbnail
              paintThumb(cThumbL, still, measurementLine, `‚âà ${inches.toFixed(0)} in`, "#ef4444", rulerLine);
              if (vL) vL.textContent = `${inches.toFixed(0)} in`;
            }
          }
        }

        // Mode switch (Diameter/Length tabs)
        function setMode(m) {
          mode = m;
          tabD.classList.toggle("active", m === "D");
          tabL.classList.toggle("active", m === "L");
          // Reset measurement line when switching dimension, keep ruler calibration
          measurementLine = null;
          line = null;
          // Don't auto-capture - keep current still or live video
          updateUI();
          draw();
        }
        tabD.addEventListener("click", () => setMode("D"));
        tabL.addEventListener("click", () => setMode("L"));

        // Capture button - freeze the camera feed
        btnCapture.addEventListener("click", () => {
          if (captureStill()) {
            draw();
            updateUI();
          }
        });

        // Retake - go back to live video
        btnRetake.addEventListener("click", () => {
          // Clear all lines and measurements
          rulerLine = null;
          measurementLine = null;
          line = null;
          pxPerInch = null;
          drawMode = "ruler";

          // Clear the appropriate input field based on mode
          if (mode === "D") {
            if (calculatedDiameter) calculatedDiameter.value = "";
            measuredD = null;
          } else {
            if (calculatedLength) calculatedLength.value = "";
            measuredL = null;
          }
          resetZoom();
          still = null; // Clear still to show live video
          draw();
          updateUI();
        });

        // Ruler button - switch to ruler drawing mode
        btnModeRuler.addEventListener("click", () => {
          drawMode = "ruler";
          line = null; // Clear current line
          updateUI();
          draw();
        });

        // Full Measurement button - switch to measurement drawing mode
        btnModeMeasure.addEventListener("click", () => {
          if (!rulerLine) {
            alert("Please draw the ruler calibration line first.");
            return;
          }
          if (!pxPerInch) {
            const ref = parseFloat(refIn.value);
            if (!isFinite(ref) || ref <= 0) {
              alert("Please enter a valid reference length (e.g., 6 or 12 inches).");
              return;
            }
            // Calculate pxPerInch now
            const rulerPx = Math.hypot(rulerLine.x2 - rulerLine.x1, rulerLine.y2 - rulerLine.y1);
            pxPerInch = rulerPx / ref;
          }
          drawMode = "measurement";
          line = null; // Clear current line
          updateUI();
          draw();
        });

        // Auto-calculate when reference inches changes
        refIn.addEventListener("input", () => {
          autoCalculate();
        });

        // Apply button - transfer values to main calculator page and close modal
        btnApply.addEventListener("click", () => {
          const diameterValue = parseFloat(calculatedDiameter.value);
          const lengthValue = parseFloat(calculatedLength.value);

          let applied = false;

          // Apply diameter if it exists
          if (isFinite(diameterValue) && diameterValue > 0 && measuredD) {
            showGeo();
            putVal(geoDiameter, measuredD);
            applied = true;
          }

          // Apply length if it exists
          if (isFinite(lengthValue) && lengthValue > 0 && measuredL) {
            showGeo();
            putVal(geoLength, measuredL);
            applied = true;
          }

          if (applied) {
            // Reset all modal state
            measuredD = measuredL = null;
            line = null;
            rulerLine = null;
            measurementLine = null;
            still = null;
            pxPerInch = null;
            drawMode = "ruler";

            // Clear input fields
            if (calculatedDiameter) calculatedDiameter.value = "";
            if (calculatedLength) calculatedLength.value = "";

            // Clear thumbnails
            vD.textContent = "";
            vL.textContent = "";
            if (cThumbD) {
              const ctx = cThumbD.getContext("2d");
              ctx.clearRect(0, 0, cThumbD.width, cThumbD.height);
            }
            if (cThumbL) {
              const ctx = cThumbL.getContext("2d");
              ctx.clearRect(0, 0, cThumbL.width, cThumbL.height);
            }

            // Close the modal
            closeModal();
          } else {
            alert("Please complete at least one measurement by drawing ruler and measurement lines.");
          }
        });

        // Open/close modal
        function openModal() {
          modal.classList.add("open");
          measuredD = measuredL = null;
          line = null;
          rulerLine = null;
          measurementLine = null;
          still = null;
          pxPerInch = null;
          drawMode = "ruler";
          vD.textContent = "";
          vL.textContent = "";
          // Clear all input fields
          if (calculatedDiameter) calculatedDiameter.value = "";
          if (calculatedLength) calculatedLength.value = "";
          // Set default reference value
          refIn.value = "12";
          resetZoom();
          updateUI();
          openCam().then(() => {
            fitAndDraw();
          });
        }
        function closeModal() {
          modal.classList.remove("open");
          stopVideoLoop();
          closeCam();
          resetZoom();
        }
        btnClose.addEventListener("click", closeModal);

        // Ensure modal is closed on page load/hard reload
        if (modal) {
          modal.classList.remove("open");
          closeCam(); // Also close camera if it was left open
        }

        // Wire up main page triggers
        document.getElementById("btnMeasure")?.addEventListener("click", openModal);

        // Track if page just loaded to prevent auto-opening modal on browser form restoration
        let pageJustLoaded = true;
        setTimeout(() => {
          pageJustLoaded = false;
        }, 100);

        document.getElementById("tankType")?.addEventListener("change", (e) => {
          // Only auto-open modal if this is a real user interaction, not initial page load
          if (e.target.value === "laydown" && !pageJustLoaded) {
            openModal();
          }
        });

        // Resize
        window.addEventListener("resize", () => {
          if (modal.classList.contains("open")) fitAndDraw();
        });
      })();
    </script>
    <!-- === SCRIPTS: MEASURE MODAL END === -->

    <!-- === SCRIPTS: CALCULATOR START === -->
    <script>
      (function () {
        /* ----- Gas constants (define if missing) ----- */
        // You can tweak these to match your operation‚Äôs tables.
        // Defaults are typical STP approximations used in industry.
        window.gases = window.gases || {
          LIN: { scfPerGal: 93.1, lbPerGal: 6.74, scfPerLb: 13.8 }, // Nitrogen
          LOX: { scfPerGal: 115.0, lbPerGal: 9.52, scfPerLb: 12.06 }, // Oxygen
          LAR: { scfPerGal: 87.3, lbPerGal: 9.4, scfPerLb: 9.3 }, // Argon
        };

        /* ----- API Configuration ----- */
        const API_ENDPOINT = "https://script.google.com/macros/s/AKfycbwrb3d-OvJUtUCkvMMnwlFRnFeeE4EQUcFMYykUewWpme8f_0lTSs6DteWwGelBPbGD/exec";

        function getAuth() {
          try {
            return JSON.parse(localStorage.getItem("cryo_auth") || "null");
          } catch {
            return null;
          }
        }

        /* ----- Hide Save and Records buttons for guest users ----- */
        (function hideButtonsForGuest() {
          const auth = getAuth();
          if (auth && auth.role === "guest") {
            const btnSave = document.getElementById("btnSave");
            const btnSaveSplit = document.getElementById("btnSaveSplit");
            const btnSaveReserve = document.getElementById("btnSaveReserve");
            const btnHistory = document.getElementById("btnHistory");
            const btnHistorySplit = document.getElementById("btnHistorySplit");
            const btnHistoryReserve = document.getElementById("btnHistoryReserve");
            if (btnSave) btnSave.style.display = "none";
            if (btnSaveSplit) btnSaveSplit.style.display = "none";
            if (btnSaveReserve) btnSaveReserve.style.display = "none";
            if (btnHistory) btnHistory.style.display = "none";
            if (btnHistorySplit) btnHistorySplit.style.display = "none";
            if (btnHistoryReserve) btnHistoryReserve.style.display = "none";
          }
        })();

        /* ----- Save Calculation to Backend ----- */
        window.saveCalculation = async function () {
          const auth = getAuth();
          const output = document.getElementById("output");
          const btnSave = document.getElementById("btnSave");

          if (!auth || !auth.token) {
            alert("Please login to save records.\n\nReload the app and login with your credentials.");
            return;
          }

          // Check if calculation has been performed (don't recalculate to preserve user adjustments)
          if (!output || !output.textContent || output.textContent.includes("Enter values") || output.textContent.includes("Please enter")) {
            alert("Cannot save - please calculate first before saving.");
            return;
          }

          // Check if Total Formulated SCF has a value
          const totalFormulatedScf = document.getElementById("totalFormulatedScf")?.value;
          if (!totalFormulatedScf || totalFormulatedScf === "") {
            alert("Cannot save - please calculate first to generate Total Formulated SCF.");
            return;
          }

          // Clean result text - remove technical labels that shouldn't be saved
          function cleanResultText(text) {
            return text
              .replace(/\s*\(linear\)/gi, "")
              .replace(/\s*\(local\):?/gi, "")
              .replace(/\s*\(official\):?/gi, "")
              .replace(/\s*\(geometry\)/gi, "")
              .replace(/\s*\(primary\)/gi, "")
              .replace(/Vertical Tank\s*/gi, "")
              .replace(/Results ‚Äî\s*/gi, "")
              .replace(/Inches\s*‚Ä¢?\s*/gi, "")
              .replace(/Timer √ó Flow\s*‚Ä¢?\s*/gi, "")
              .replace(/\s+/g, " ")
              .trim();
          }

          // Collect calculation data
          const record = {
            tank_type: document.getElementById("tankType")?.value || "",
            full_inches: document.getElementById("fullInches")?.value || "",
            start_inches: document.getElementById("startInches")?.value || "",
            end_inches: document.getElementById("endInches")?.value || "",
            start_psi: document.getElementById("startPsi")?.value || "",
            end_psi: document.getElementById("endPsi")?.value || "",
            capacity: document.getElementById("fullCap")?.value || "",
            capacity_unit: document.getElementById("capUnit")?.value || "",
            gas: document.getElementById("gas")?.value || "",
            flow_value: document.getElementById("flowValue")?.value || "",
            metered_scf: document.getElementById("meteredScf")?.value || "",
            total_formulated_scf: document.getElementById("totalFormulatedScf")?.value || "",
            timer_elapsed: document.getElementById("elapsed")?.textContent || "",
            result_text: cleanResultText(output.textContent).substring(0, 800) + " ‚Ä¢ " +
                   "Starting (in)/PSI: " + (document.getElementById("startInches")?.value || "-") + " | " + (document.getElementById("startPsi")?.value || "-") + " ‚Ä¢ " +
                   "Ending (in)/PSI: " + (document.getElementById("endInches")?.value || "-") + " | " + (document.getElementById("endPsi")?.value || "-") +
                   (document.getElementById("meteredScf")?.value ? " ‚Ä¢ Metered: " + document.getElementById("meteredScf")?.value + " SCF" : "") +
                   (document.getElementById("totalFormulatedScf")?.value ? " ‚Ä¢ Total Formulated: " + document.getElementById("totalFormulatedScf")?.value + " SCF" : ""),
            timestamp: new Date().toISOString()
          };

          // Disable button and show loading
          btnSave.disabled = true;
          btnSave.textContent = "Saving...";

          try {
            // Use text/plain to avoid CORS preflight (no OPTIONS request)
            // Apps Script will still parse JSON from the body
            const response = await fetch(API_ENDPOINT, {
              method: "POST",
              headers: {
                "Content-Type": "text/plain"
              },
              body: JSON.stringify({
                action: "save",
                type: "calc",
                token: auth.token,
                record: record
              }),
              redirect: "follow"
            });

            const data = await response.json();

            if (data.ok) {
              alert("‚úì Calculation saved successfully!");
            } else {
              alert("Save failed: " + (data.error || "Unknown error"));
            }
          } catch (err) {
            console.error("Save error:", err);
            alert("Network error. Please check your connection.");
          } finally {
            btnSave.disabled = false;
            btnSave.textContent = "üíæ Save";
          }
        };

        /* ----- Save Split Calculation to Backend ----- */
        window.saveSplit = async function () {
          const auth = getAuth();
          const btnSaveSplit = document.getElementById("btnSaveSplit");

          if (!auth || !auth.token) {
            alert("Please login to save records.\n\nReload the app and login with your credentials.");
            return;
          }

          // Compute and display first
          if (typeof window.calcSplit === "function") {
            window.calcSplit();
          }

          const t1SCF = document.getElementById("t1SCF")?.value || "";
          const t2SCF = document.getElementById("t2SCF")?.value || "";

          if (!t1SCF || !t2SCF || t1SCF === "0" || t2SCF === "0") {
            alert("Cannot save - please ensure Total SCF and both tank inch ranges are filled.");
            return;
          }

          // Collect split data matching Google Sheet columns:
          // record_id, user_id, timestamp, source_tank, destination, amount_scf, gas, notes, result_text, source
          // Plus new fields: t1_start_inches, t1_start_psi, t1_end_inches, t1_end_psi, t2_start_inches, t2_start_psi, t2_end_inches, t2_end_psi
          const record = {
            source_tank: document.getElementById("splitTotalSCF")?.value || "",
            destination: "Tank1: " + t1SCF + " SCF, Tank2: " + t2SCF + " SCF",
            amount_scf: document.getElementById("splitTotalSCF")?.value || "",
            gas: document.getElementById("splitGas")?.value || "",
            // Tank 1 inches and PSI
            tank1_start_inches: document.getElementById("t1StartInches")?.value || "",
            tank1_start_psi: document.getElementById("t1StartPsi")?.value || "",
            tank1_end_inches: document.getElementById("t1EndInches")?.value || "",
            tank1_end_psi: document.getElementById("t1EndPsi")?.value || "",
            // Tank 2 inches and PSI
            tank2_start_inches: document.getElementById("t2StartInches")?.value || "",
            tank2_start_psi: document.getElementById("t2StartPsi")?.value || "",
            tank2_end_inches: document.getElementById("t2EndInches")?.value || "",
            tank2_end_psi: document.getElementById("t2EndPsi")?.value || "",
            notes: "T1: " + (document.getElementById("t1StartInches")?.value || "0") + "-" + (document.getElementById("t1EndInches")?.value || "0") + "in, " +
                   "T2: " + (document.getElementById("t2StartInches")?.value || "0") + "-" + (document.getElementById("t2EndInches")?.value || "0") + "in",
            result_text: "Total: " + (document.getElementById("splitTotalSCF")?.value || "0") + " SCF ‚Üí Tank1: " + t1SCF + " SCF, Tank2: " + t2SCF + " SCF ‚Ä¢ " +
                   "Tank1 Starting (in)/PSI: " + (document.getElementById("t1StartInches")?.value || "-") + " | " + (document.getElementById("t1StartPsi")?.value || "-") + " ‚Ä¢ " +
                   "Tank1 Ending (in)/PSI: " + (document.getElementById("t1EndInches")?.value || "-") + " | " + (document.getElementById("t1EndPsi")?.value || "-") + " ‚Ä¢ " +
                   "Tank2 Starting (in)/PSI: " + (document.getElementById("t2StartInches")?.value || "-") + " | " + (document.getElementById("t2StartPsi")?.value || "-") + " ‚Ä¢ " +
                   "Tank2 Ending (in)/PSI: " + (document.getElementById("t2EndInches")?.value || "-") + " | " + (document.getElementById("t2EndPsi")?.value || "-"),
            timestamp: new Date().toISOString()
          };

          // Disable button and show loading
          btnSaveSplit.disabled = true;
          btnSaveSplit.textContent = "Saving...";

          try {
            const response = await fetch(API_ENDPOINT, {
              method: "POST",
              headers: {
                "Content-Type": "text/plain"
              },
              body: JSON.stringify({
                action: "save",
                type: "split",
                token: auth.token,
                record: record
              }),
              redirect: "follow"
            });

            const data = await response.json();

            if (data.ok) {
              alert("‚úì Split calculation saved successfully!");
            } else {
              alert("Save failed: " + (data.error || "Unknown error"));
            }
          } catch (err) {
            console.error("Save error:", err);
            alert("Network error. Please check your connection.");
          } finally {
            btnSaveSplit.disabled = false;
            btnSaveSplit.textContent = "üíæ Save";
          }
        };

        /* ----- Save Reserve Calculation to Backend ----- */
        window.saveReserve = async function () {
          const auth = getAuth();
          const btnSaveReserve = document.getElementById("btnSaveReserve");

          if (!auth || !auth.token) {
            alert("Please login to save records.\n\nReload the app and login with your credentials.");
            return;
          }

          // Compute and display first
          if (typeof window.calcReserve === "function") {
            window.calcReserve();
          }

          const remaining = document.getElementById("resRemaining")?.value || "";

          if (!remaining || remaining === "0") {
            alert("Cannot save - please enter Amount and select Gas type first.");
            return;
          }

          // Collect reserve data matching Google Sheet columns:
          // record_id, user_id, timestamp, reserve_amount, gas, remaining, warning_flag, result_text, source
          const resAmount = document.getElementById("resAmount")?.value || "";
          const resGas = document.getElementById("resGas")?.value || "";
          const t1 = document.getElementById("resT1")?.value || "0";
          const t2 = document.getElementById("resT2")?.value || "0";
          const t3 = document.getElementById("resT3")?.value || "0";
          const t4 = document.getElementById("resT4")?.value || "0";

          const remainingNum = parseFloat(remaining) || 0;
          const warningFlag = remainingNum < 0 ? "OVER" : (remainingNum < 1000 ? "LOW" : "OK");

          const record = {
            reserve_amount: resAmount,
            gas: resGas,
            remaining: remaining,
            warning_flag: warningFlag,
            result_text: "Amount: " + resAmount + " " + resGas + " ‚Üí Tanks: " + t1 + "/" + t2 + "/" + t3 + "/" + t4 + " SCF ‚Üí Remaining: " + remaining + " SCF",
            timestamp: new Date().toISOString()
          };

          // Disable button and show loading
          btnSaveReserve.disabled = true;
          btnSaveReserve.textContent = "Saving...";

          try {
            const response = await fetch(API_ENDPOINT, {
              method: "POST",
              headers: {
                "Content-Type": "text/plain"
              },
              body: JSON.stringify({
                action: "save",
                type: "reserve",
                token: auth.token,
                record: record
              }),
              redirect: "follow"
            });

            const data = await response.json();

            if (data.ok) {
              alert("‚úì Reserve calculation saved successfully!");
            } else {
              alert("Save failed: " + (data.error || "Unknown error"));
            }
          } catch (err) {
            console.error("Save error:", err);
            alert("Network error. Please check your connection.");
          } finally {
            btnSaveReserve.disabled = false;
            btnSaveReserve.textContent = "üíæ Save";
          }
        };

        /* ----- UI: show/hide laydown-only fields ----- */
        const tankTypeSel = document.getElementById("tankType");
        const geoFields = document.getElementById("geoFields");
        const geoDiameter = document.getElementById("geoDiameter");
        const geoLength = document.getElementById("geoLength");
        const diamHint = document.getElementById("diamHint");

        function setGeoVisibility() {
          const isLaydown = tankTypeSel && tankTypeSel.value === "laydown";
          if (geoFields) geoFields.hidden = !isLaydown;
          if (geoDiameter) geoDiameter.disabled = !isLaydown;
          if (geoLength) geoLength.disabled = !isLaydown;
          if (diamHint) diamHint.hidden = !isLaydown;
        }
        if (tankTypeSel) {
          tankTypeSel.addEventListener("change", setGeoVisibility);
          setGeoVisibility();
        }

        /* ----- TIMER (Start/Stop) ----- */
        let t0 = null,
          t1 = null,
          intervalId = null;
        const $elapsed = document.getElementById("elapsed");
        const $btnStart = document.getElementById("btnStart");
        const $btnStop = document.getElementById("btnStop");

        function fmtTime(ms) {
          if (!ms || ms < 0) return "00:00:00";
          const s = Math.floor(ms / 1000);
          const h = String(Math.floor(s / 3600)).padStart(2, "0");
          const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
          const sec = String(s % 60).padStart(2, "0");
          return `${h}:${m}:${sec}`;
        }
        function updateElapsed() {
          if (!t0) return;
          const now = t1 && Number.isFinite(t1) ? t1 : Date.now();
          if ($elapsed) $elapsed.textContent = "Elapsed: " + fmtTime(now - t0);
        }
        function startTimer() {
          t0 = Date.now();
          t1 = null;
          if ($elapsed) $elapsed.textContent = "Elapsed: 00:00:00";
          if (intervalId) clearInterval(intervalId);
          intervalId = setInterval(updateElapsed, 250);
          if ($btnStart) $btnStart.disabled = true;
          if ($btnStop) $btnStop.disabled = false;
        }
        function stopTimer() {
          if (!t0) return;
          t1 = Date.now();
          if (intervalId) clearInterval(intervalId);
          updateElapsed();
          if ($btnStart) $btnStart.disabled = false;
          if ($btnStop) $btnStop.disabled = true;
        }
        $btnStart?.addEventListener("click", startTimer);
        $btnStop?.addEventListener("click", stopTimer);

        /* ----- Flow unit toggle (gal/min ‚Üî lb/min) ----- */
        const unitSwitch = document.getElementById("unitSwitch");
        function isLbMode() {
          return unitSwitch && unitSwitch.classList.contains("on");
        }
        function setUnitSwitch(on) {
          if (!unitSwitch) return;
          unitSwitch.classList.toggle("on", !!on);
          unitSwitch.setAttribute("aria-checked", on ? "true" : "false");
        }
        unitSwitch?.addEventListener("click", () => setUnitSwitch(!isLbMode()));
        unitSwitch?.addEventListener("keydown", (e) => {
          if (e.key === " " || e.key === "Enter") {
            e.preventDefault();
            setUnitSwitch(!isLbMode());
          }
        });
        setUnitSwitch(false);

        /* ----- Geometry helpers for horizontal tanks ----- */
        function horizFrac(d, h) {
          // d: cylinder diameter (in), h: liquid height (in)
          const R = d / 2;
          if (!Number.isFinite(d) || !Number.isFinite(h)) return 0;
          if (h <= 0) return 0;
          if (h >= 2 * R) return 1;
          const a = Math.acos((R - h) / R);
          const Aseg = R * R * a - (R - h) * Math.sqrt(Math.max(0, 2 * R * h - h * h));
          return Aseg / (Math.PI * R * R);
        }
        function estimateDiameterFromTimer(fullSCF, start, end, scfDelivered, dMin = 60, dMax = 130, step = 0.1) {
          let bestD = null,
            bestErr = Infinity;
          for (let d = dMin; d <= dMax; d += step) {
            const pred = fullSCF * (horizFrac(d, end) - horizFrac(d, start));
            const err = Math.abs(pred - scfDelivered);
            if (err < bestErr) {
              bestErr = err;
              bestD = d;
            }
          }
          return { d: bestD, err: bestErr };
        }
        // subtract short ‚Äúdead time‚Äù for horizontal fills when using timer
        function adjustedElapsedMin(rawMin) {
          if (!rawMin) return null;
          const deadSec = Math.min(30, Math.max(10, rawMin * 60 * 0.05));
          return Math.max(0, rawMin - deadSec / 60);
        }

        /* ----- CALCULATE (exposed for button onclick) ----- */
        window.calculate = function () {
          const tankType = document.getElementById("tankType")?.value || "vertical";
          const gasKey = document.getElementById("gas")?.value || "LIN";
          const gas = window.gases && window.gases[gasKey] ? window.gases[gasKey] : null;
          const output = document.getElementById("output");

          if (!gas) {
            output.innerHTML = "Gas constants missing. Please verify LIN/LOX/LAR constants.";
            return;
          }

          const capUnit = document.getElementById("capUnit")?.value || "scf";
          const fullCapEntered = parseFloat(document.getElementById("fullCap")?.value);
          if (!Number.isFinite(fullCapEntered)) {
            output.innerHTML = "Please enter a valid Full Capacity value (SCF or Gallons).";
            return;
          }
          const fullSCF = capUnit === "gal" ? fullCapEntered * gas.scfPerGal : fullCapEntered;

          const start = parseFloat(document.getElementById("startInches")?.value);
          const end = parseFloat(document.getElementById("endInches")?.value);

          const elapsedMs = t0 && (t1 || Date.now()) ? (t1 || Date.now()) - t0 : null;
          let elapsedMin = elapsedMs ? elapsedMs / 1000 / 60 : null;
          let effectiveElapsedMin = elapsedMin;
          if (tankType === "laydown" && elapsedMin && elapsedMin > 0) {
            effectiveElapsedMin = adjustedElapsedMin(elapsedMin);
          }

          const flowVal = parseFloat(document.getElementById("flowValue")?.value);
          let flowGPM = null;
          if (Number.isFinite(flowVal)) flowGPM = isLbMode() ? flowVal / gas.lbPerGal : flowVal;
          const flowScfMin = flowGPM ? flowGPM * gas.scfPerGal : null;

          // Metered SCF from truck flow meter
          const meteredScf = parseFloat(document.getElementById("meteredScf")?.value);

          const wantEstimateD = document.getElementById("chkEstimateD")?.checked;
          const useTimerPrimary = document.getElementById("useTimerPrimary")?.checked;

          const fullTrycockIn = parseFloat(document.getElementById("fullInches")?.value);
          const cylD = parseFloat(document.getElementById("geoDiameter")?.value);
          let html = "";

          /* Flow-only estimate if no inches provided */
          const inchesMissing = !Number.isFinite(start) || !Number.isFinite(end);
          if (flowGPM && effectiveElapsedMin && inchesMissing) {
            const totalGallons = flowGPM * effectiveElapsedMin;
            const totalSCF = totalGallons * gas.scfPerGal;
            const enteredLabel = isLbMode() ? `${flowVal.toFixed(1)} lb/min` : `${flowVal.toFixed(1)} gal/min`;
            html += `<h2>Flow-Only Estimate</h2>`;
            html += `<p>Elapsed Time: <b>${fmtTime(effectiveElapsedMin * 60 * 1000)}</b> &nbsp; | &nbsp; Flow: <b>${enteredLabel}</b></p>`;
            html += `<p><b>Estimated Product Moved:</b> ${totalGallons.toFixed(1)} gal &nbsp; (~${totalSCF.toFixed(0)} SCF)</p><hr>`;
          }

          /* Timer-first path */
          let scf_timer = null;
          if (useTimerPrimary && effectiveElapsedMin && flowScfMin && flowScfMin > 0) {
            scf_timer = flowScfMin * effectiveElapsedMin;
          }

          /* Inches-based path */
          let haveInches = Number.isFinite(start) && Number.isFinite(end) && Number.isFinite(fullSCF);
          let scf_inches = null,
            modeLabel = "",
            usedD = cylD,
            estNote = "",
            scfPerInchShown = null;

          if (haveInches) {
            if (tankType === "laydown") {
              if (Number.isFinite(cylD) && cylD > 0) {
                const fs = horizFrac(cylD, Math.max(0, start));
                const fe = horizFrac(cylD, Math.max(0, end));
                scf_inches = fullSCF * (fe - fs);
                modeLabel = "Laydown Tank (geometry)";
                const mid = (start + end) / 2,
                  eps = 0.01;
                const df = (horizFrac(cylD, mid + eps) - horizFrac(cylD, mid - eps)) / (2 * eps);
                scfPerInchShown = fullSCF * df;
              } else if (wantEstimateD && effectiveElapsedMin && flowScfMin && flowScfMin > 0) {
                const scfDelivered = flowScfMin * effectiveElapsedMin;
                const { d } = estimateDiameterFromTimer(fullSCF, Math.max(0, start), Math.max(0, end), scfDelivered);
                if (d) {
                  usedD = d;
                  estNote = ` (estimated D: ${d.toFixed(1)} in)`;
                }
                const fs = horizFrac(usedD, Math.max(0, start));
                const fe = horizFrac(usedD, Math.max(0, end));
                scf_inches = fullSCF * (fe - fs);
                modeLabel = "Laydown Tank (geometry, est. D)";
                const mid = (start + end) / 2,
                  eps = 0.01;
                const df = (horizFrac(usedD, mid + eps) - horizFrac(usedD, mid - eps)) / (2 * eps);
                scfPerInchShown = fullSCF * df;
              } else if (Number.isFinite(fullTrycockIn) && fullTrycockIn > 0) {
                // simple fallback if no diameter available
                const linearFactor = 0.94;
                scf_inches = (end - start) * (fullSCF / fullTrycockIn) * linearFactor;
                modeLabel = "Laydown Tank (empirical linear)";
                scfPerInchShown = (fullSCF / fullTrycockIn) * linearFactor;
                html += `<p class="muted">Laydown fallback used: linear ratio √ó0.94 (no cylinder diameter provided).</p>`;
              } else {
                html += `<p class="muted">Provide cylinder diameter (or enable ‚ÄúEstimate diameter from timer‚Äù) to map laydown inches.</p>`;
              }
            } else {
              const denom = Number.isFinite(fullTrycockIn) && fullTrycockIn > 0 ? fullTrycockIn : 1;
              const spi = fullSCF / denom;
              scf_inches = (end - start) * spi;
              modeLabel = "Vertical Tank (linear)";
              scfPerInchShown = spi;
            }
          }

          /* Pick official result */
          let scf = null,
            source = "";
          if (useTimerPrimary && scf_timer != null) {
            scf = scf_timer;
            source = "Timer √ó Flow (primary)";
          } else if (haveInches && scf_inches != null) {
            scf = scf_inches;
            source = tankType === "laydown" ? "Inches (geometry)" : "Inches (linear)";
          } else if (scf_timer != null) {
            scf = scf_timer;
            source = "Timer √ó Flow";
          }

          if (scf == null) {
            output.innerHTML = html + "Not enough info. Provide inches OR enable timer with flow.";
            return;
          }

          const gallons = scf / gas.scfPerGal;
          const poundsFromGallons = gallons * gas.lbPerGal;
          const poundsFromSCF = scf / gas.scfPerLb;

          let compLine = "";
          if (scf_timer != null && scf_inches != null) {
            const pct = scf_inches === 0 ? 0 : ((scf_timer - scf_inches) / scf_inches) * 100;
            compLine = `Timer vs Inches Œî: <b>${pct.toFixed(2)}%</b>`;
          }

          const flowFromTimerScfMin = effectiveElapsedMin && effectiveElapsedMin > 0 ? scf / effectiveElapsedMin : null;
          const flowFromTimerGPM = flowFromTimerScfMin ? flowFromTimerScfMin / gas.scfPerGal : null;
          const flowFromTimerLBPM = flowFromTimerGPM ? flowFromTimerGPM * gas.lbPerGal : null;

          html += `<h2>Results ‚Äî ${source}${modeLabel ? " ‚Ä¢ " + modeLabel : ""}</h2>`;
          if (haveInches) {
            html += `<p>Change (in): ${(end - start).toFixed(2)}</p>`;
            if (tankType === "laydown" && (Number.isFinite(usedD) || Number.isFinite(cylD))) {
              html += `<p>Diameter used: <b>${(Number.isFinite(cylD) ? cylD : usedD).toFixed(2)} in</b>${estNote || ""}</p>`;
            }
          }
          // Show metered SCF comparison if user entered/captured a meter reading
          if (Number.isFinite(meteredScf) && meteredScf > 0) {
            const meteredDiff = scf - meteredScf;
            const meteredPct = meteredScf === 0 ? 0 : ((scf - meteredScf) / meteredScf) * 100;
            html += `<p>Truck Meter: <b>${meteredScf.toFixed(0)} SCF</b> &nbsp;|&nbsp; Œî: <b>${meteredDiff >= 0 ? '+' : ''}${meteredDiff.toFixed(0)} SCF</b> (${meteredPct >= 0 ? '+' : ''}${meteredPct.toFixed(1)}%)</p>`;
          }
          if (compLine) html += `<p>${compLine}</p>`;

          html += `<hr>`;
          html += `<p><b>Total SCF (official):</b> ${scf.toFixed(2)}</p>`;
          html += `<p><b>Gallons (~SCF √∑ ${gas.scfPerGal}):</b> ${gallons.toFixed(2)}</p>`;
          html += `<p><b>Pounds (Gallons √ó ${gas.lbPerGal}):</b> ${poundsFromGallons.toFixed(2)}</p>`;
          html += `<p><b>Pounds (SCF √∑ ${gas.scfPerLb}):</b> ${poundsFromSCF.toFixed(2)}</p>`;
          html += `<p>Timer: <span class="mono">${elapsedMs ? fmtTime(elapsedMs) : "‚Äî"}</span>`;
          if (Number.isFinite(flowVal) && effectiveElapsedMin) {
            const entered = isLbMode() ? `${flowVal.toFixed(1)} lb/min` : `${flowVal.toFixed(1)} gal/min`;
            html += ` &nbsp; | &nbsp; Entered Flow: <span class="mono">${entered}</span>`;
          }
          if (flowFromTimerGPM && effectiveElapsedMin) {
            html += ` &nbsp; | &nbsp; Flow from timer + result: <span class="mono">${flowFromTimerGPM.toFixed(1)} gal/min</span>`;
            html += ` &nbsp; (<span class="mono">${flowFromTimerLBPM.toFixed(1)} lb/min</span>)`;
          }
          html += `</p>`;

          output.innerHTML = html;

          // Update Total Formulated SCF field
          const totalFormulatedScfEl = document.getElementById("totalFormulatedScf");
          if (totalFormulatedScfEl) {
            // Store the original calculated SCF value (global)
            window.originalCalculatedScf = scf;
            window.scfAdjustmentPercent = 0; // Reset adjustment percentage
            totalFormulatedScfEl.value = scf.toFixed(2);

            // Save to localStorage after calculation
            if (typeof saveFormToSession === "function") {
              saveFormToSession();
            }
          }

          // push to Split page input
          if (typeof window.setAutoSCFTotal === "function") {
            window.setAutoSCFTotal(Number(scf.toFixed(0)));
          }
        };

        /* ----- ADJUST TOTAL SCF (exposed for adjustment buttons) ----- */
        window.adjustTotalScf = function (percentAmount) {
          // Check if we have a calculated value
          if (!window.originalCalculatedScf || window.originalCalculatedScf <= 0) {
            alert("Please calculate first before adjusting the total.");
            return;
          }

          const totalFormulatedScfEl = document.getElementById("totalFormulatedScf");
          if (!totalFormulatedScfEl) return;

          // Add the adjustment percentage (0.05 means 0.05%, 0.10 means 0.10%)
          window.scfAdjustmentPercent = (window.scfAdjustmentPercent || 0) + percentAmount;

          // Calculate percentage adjustment (convert 0.05% to 0.0005, 0.10% to 0.0010)
          const percentageMultiplier = window.scfAdjustmentPercent / 100;
          const adjustment = window.originalCalculatedScf * percentageMultiplier;

          // Calculate new total
          const newTotal = window.originalCalculatedScf + adjustment;

          // Update the field
          totalFormulatedScfEl.value = newTotal.toFixed(2);

          // Save to localStorage after adjustment
          if (typeof saveFormToSession === "function") {
            saveFormToSession();
          }
        };

        /* ----- CLEAR (exposed for button onclick) ----- */
        window.clearForm = function () {
          ["fullInches", "fullCap", "startInches", "endInches", "startPsi", "endPsi", "flowValue", "geoDiameter", "geoLength", "meteredScf", "totalFormulatedScf"].forEach((id) => {
            const el = document.getElementById(id);
            if (el) el.value = "";
          });
          // Reset Total Formulated SCF tracking variables
          window.originalCalculatedScf = 0;
          window.scfAdjustmentPercent = 0;

          const capSel = document.getElementById("capUnit");
          if (capSel) capSel.value = "scf";
          const chk1 = document.getElementById("chkEstimateD");
          if (chk1) chk1.checked = false;
          const chk2 = document.getElementById("useTimerPrimary");
          if (chk2) chk2.checked = false;
          const out = document.getElementById("output");
          if (out) out.innerHTML = "Enter values and tap Calculate.";
          if ($elapsed) $elapsed.textContent = "Elapsed: 00:00:00";
          if (intervalId) clearInterval(intervalId);
          t0 = null;
          t1 = null;
          intervalId = null;
          if (unitSwitch) {
            unitSwitch.classList.remove("on");
            unitSwitch.setAttribute("aria-checked", "false");
          }
          if ($btnStart) $btnStart.disabled = false;
          if ($btnStop) $btnStop.disabled = true;
          setGeoVisibility();

          // Clear localStorage when clearing form
          localStorage.removeItem("calculatorFormData");
        };

        /* ----- SESSION STORAGE: Save/Load Form Values ----- */
        const formFields = [
          "tankType", "fullInches", "fullCap", "capUnit", "gas",
          "startInches", "startPsi", "endInches", "endPsi",
          "flowValue", "meteredScf", "geoDiameter", "geoLength",
          "totalFormulatedScf"
        ];

        // Save form data to localStorage
        function saveFormToSession() {
          const formData = {};

          // Save input/select values
          formFields.forEach(id => {
            const el = document.getElementById(id);
            if (el) formData[id] = el.value;
          });

          // Save checkboxes
          const chkEstimateD = document.getElementById("chkEstimateD");
          const useTimerPrimary = document.getElementById("useTimerPrimary");
          if (chkEstimateD) formData.chkEstimateD = chkEstimateD.checked;
          if (useTimerPrimary) formData.useTimerPrimary = useTimerPrimary.checked;

          // Save unit switch state
          if (unitSwitch) formData.unitSwitchOn = unitSwitch.classList.contains("on");

          // Save adjustment tracking variables
          if (window.originalCalculatedScf) formData.originalCalculatedScf = window.originalCalculatedScf;
          if (window.scfAdjustmentPercent) formData.scfAdjustmentPercent = window.scfAdjustmentPercent;

          localStorage.setItem("calculatorFormData", JSON.stringify(formData));
        }

        // Load form data from localStorage
        function loadFormFromSession() {
          const saved = localStorage.getItem("calculatorFormData");
          if (!saved) return;

          try {
            const formData = JSON.parse(saved);

            // Restore input/select values
            formFields.forEach(id => {
              const el = document.getElementById(id);
              if (el && formData[id] !== undefined && formData[id] !== "") {
                el.value = formData[id];
              }
            });

            // Restore checkboxes
            const chkEstimateD = document.getElementById("chkEstimateD");
            const useTimerPrimary = document.getElementById("useTimerPrimary");
            if (chkEstimateD && formData.chkEstimateD !== undefined) {
              chkEstimateD.checked = formData.chkEstimateD;
            }
            if (useTimerPrimary && formData.useTimerPrimary !== undefined) {
              useTimerPrimary.checked = formData.useTimerPrimary;
            }

            // Restore unit switch state
            if (unitSwitch && formData.unitSwitchOn !== undefined) {
              setUnitSwitch(formData.unitSwitchOn);
            }

            // Restore adjustment tracking variables
            if (formData.originalCalculatedScf) {
              window.originalCalculatedScf = formData.originalCalculatedScf;
            }
            if (formData.scfAdjustmentPercent !== undefined) {
              window.scfAdjustmentPercent = formData.scfAdjustmentPercent;
            }

            // Trigger visibility updates
            setGeoVisibility();
          } catch (e) {
            console.error("Error loading form data from localStorage:", e);
          }
        }

        // Auto-save on input changes
        function setupAutoSave() {
          formFields.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
              el.addEventListener("input", saveFormToSession);
              el.addEventListener("change", saveFormToSession);
            }
          });

          // Save on checkbox changes
          const chkEstimateD = document.getElementById("chkEstimateD");
          const useTimerPrimary = document.getElementById("useTimerPrimary");
          if (chkEstimateD) chkEstimateD.addEventListener("change", saveFormToSession);
          if (useTimerPrimary) useTimerPrimary.addEventListener("change", saveFormToSession);

          // Save when unit switch is toggled
          if (unitSwitch) {
            unitSwitch.addEventListener("click", saveFormToSession);
          }
        }

        // Load form data on page load
        loadFormFromSession();

        // Setup auto-save listeners
        setupAutoSave();
      })();
    </script>
    <!-- === SCRIPTS: CALCULATOR END === -->

    <!-- === SCRIPTS: SPLIT (FULLY FIXED VERSION) === -->
<script>
(function () {

  // Gas data
  const gases = {
    LIN: { scfPerLb: 13.8, scfPerGal: 93.1 },
    LOX: { scfPerLb: 12.06, scfPerGal: 115.0 },
    LAR: { scfPerLb: 9.3, scfPerGal: 87.3 },
  };

  const $ = id => document.getElementById(id);
  const num = v => parseFloat(v) || 0;

  // HTML bindings matching your page exactly
  const input = $("splitInput");
  const inputType = $("splitInputType");
  const gasSel = $("splitGas");
  const updateBtn = $("splitUpdate");
  const converted = $("splitConverted");
  const totalSCF = $("splitTotalSCF");

  const t1Full = $("t1Full");
  const t1Gal = $("t1Gal");
  const t1StartInches = $("t1StartInches");
  const t1StartPsi = $("t1StartPsi");
  const t1EndInches = $("t1EndInches");
  const t1EndPsi = $("t1EndPsi");
  const t1SCF = $("t1SCF");

  const t2Full = $("t2Full");
  const t2Gal = $("t2Gal");
  const t2StartInches = $("t2StartInches");
  const t2StartPsi = $("t2StartPsi");
  const t2EndInches = $("t2EndInches");
  const t2EndPsi = $("t2EndPsi");
  const t2SCF = $("t2SCF");

  const calcBtn = $("splitCalc");
  const clearBtn = $("splitClear");
  const err = $("splitErr");

  /* ----------------------------
     Convert Pounds ‚áÑ SCF
  -----------------------------*/
  function updateSCF() {
    const amt = num(input.value);
    if (!amt) {
      converted.textContent = "";
      totalSCF.value = "";
      checkReady();
      return;
    }

    const gas = gases[gasSel.value];

    let scf = 0;
    if (inputType.value === "POUNDS") {
      scf = amt * gas.scfPerLb;
      converted.textContent = `Converted: ${scf.toLocaleString()} SCF`;
    } else {
      scf = amt;
      converted.textContent = `Using: ${scf.toLocaleString()} SCF`;
    }

    totalSCF.value = scf.toLocaleString();
    checkReady();
  }

  updateBtn.addEventListener("click", updateSCF);

  /* ----------------------------
     Unlock Calculate button when ready
  -----------------------------*/
  function checkReady() {
    const scf = num(totalSCF.value.replace(/,/g, ""));
    const s1 = num(t1StartInches.value);
    const e1 = num(t1EndInches.value);
    const s2 = num(t2StartInches.value);
    const e2 = num(t2EndInches.value);

    const ready =
      scf > 0 &&
      e1 > s1 &&
      e2 > s2;

    calcBtn.disabled = !ready;
    if (ready) err.style.display = "none";
  }

  document.addEventListener("input", checkReady);

  /* ----------------------------
     Split Calculation (Proportional Method - Version B)
  -----------------------------*/
  window.calcSplit = function calcSplit() {
    const scf = num(totalSCF.value.replace(/,/g, ""));
    const d1 = Math.max(0, num(t1EndInches.value) - num(t1StartInches.value));
    const d2 = Math.max(0, num(t2EndInches.value) - num(t2StartInches.value));

    if (!(scf > 0 && d1 > 0 && d2 > 0)) {
      err.style.display = "block";
      return;
    }

    const total = d1 + d2;

    let a1 = Math.round((d1 / total) * scf);
    let a2 = scf - a1; // ensures perfect total match

    t1SCF.value = a1.toLocaleString();
    t2SCF.value = a2.toLocaleString();
    err.style.display = "none";
  }

  calcBtn.addEventListener("click", calcSplit);

  /* ----------------------------
     Clear
  -----------------------------*/
  clearBtn.addEventListener("click", () => {
    [
      input, totalSCF, converted,
      t1Full, t1Gal, t1StartInches, t1StartPsi, t1EndInches, t1EndPsi, t1SCF,
      t2Full, t2Gal, t2StartInches, t2StartPsi, t2EndInches, t2EndPsi, t2SCF
    ].forEach(el => el.value = "");

    err.style.display = "none";
    calcBtn.disabled = true;

    // Clear localStorage for split calculator
    localStorage.removeItem("splitCalculatorData");
  });

  /* ----------------------------
     SESSION STORAGE: Split Calculator
  -----------------------------*/
  const splitFields = [
    "splitInput", "splitInputType", "splitGas", "splitTotalSCF",
    "t1Full", "t1Gal", "t1StartInches", "t1StartPsi", "t1EndInches", "t1EndPsi", "t1SCF",
    "t2Full", "t2Gal", "t2StartInches", "t2StartPsi", "t2EndInches", "t2EndPsi", "t2SCF"
  ];

  function saveSplitToSession() {
    const data = {};
    splitFields.forEach(id => {
      const el = $(id);
      if (el) data[id] = el.value;
    });
    localStorage.setItem("splitCalculatorData", JSON.stringify(data));
  }

  function loadSplitFromSession() {
    const saved = localStorage.getItem("splitCalculatorData");
    if (!saved) return;

    try {
      const data = JSON.parse(saved);
      splitFields.forEach(id => {
        const el = $(id);
        if (el && data[id] !== undefined && data[id] !== "") {
          el.value = data[id];
        }
      });
      checkReady();
    } catch (e) {
      console.error("Error loading split data:", e);
    }
  }

  function setupSplitAutoSave() {
    splitFields.forEach(id => {
      const el = $(id);
      if (el) {
        el.addEventListener("input", saveSplitToSession);
        el.addEventListener("change", saveSplitToSession);
      }
    });
  }

  // Load and setup auto-save for split calculator
  loadSplitFromSession();
  setupSplitAutoSave();

})();
</script>
<!-- === SCRIPTS: SPLIT END === -->

<!-- === PAGE: RESERVE START === -->
<section class="pane" id="pane-reserve">
  <div class="page split">
    <h1>Cryo Reserve Calculator</h1>

    <!-- INPUT AMOUNT + TYPE -->
    <div class="row2" style="margin-top:12px;">
      <div>
        <div class="muted">Amount</div>
        <input id="resAmount" type="number" placeholder="Enter Pounds or SCF" inputmode="numeric" />
      </div>

      <div>
        <div class="muted">Input Type</div>
        <select id="resInputType">
          <option value="POUNDS">Pounds (COA)</option>
          <option value="SCF">SCF</option>
        </select>
      </div>
    </div>

    <!-- GAS + UPDATE -->
    <div class="row2" style="margin-top:10px;">
      <div>
        <div class="muted">Gas</div>
        <select id="resGas">
          <option value="LIN">LIN (Nitrogen)</option>
          <option value="LOX">LOX (Oxygen)</option>
          <option value="LAR">LAR (Argon)</option>
        </select>
      </div>

      <div style="display:flex; align-items:flex-end;">
        <button id="resUpdate" type="button" class="btn-primary">Update</button>
      </div>
    </div>

    <div id="resHint" class="muted" style="margin-top:6px;"></div>

    <!-- TANK INPUTS -->
    <div style="margin-top:16px;">
      <div class="muted"><b>Tank 1 SCF</b></div>
      <input id="resT1" type="number" placeholder="0" />
    </div>

    <div style="margin-top:12px;">
      <div class="muted"><b>Tank 2 SCF</b></div>
      <input id="resT2" type="number" placeholder="0" />
    </div>

    <div style="margin-top:12px;">
      <div class="muted"><b>Tank 3 SCF</b></div>
      <input id="resT3" type="number" placeholder="0" />
    </div>

    <div style="margin-top:12px;">
      <div class="muted"><b>Tank 4 SCF</b></div>
      <input id="resT4" type="number" placeholder="0" />
    </div>

    <!-- REMAINING -->
    <div style="margin-top:16px;">
      <div class="muted"><b>Remaining SCF</b></div>
      <input id="resRemaining" type="text" placeholder="0" readonly />
    </div>

    <div class="sticky-actions">
      <button id="resClear" class="btn-primary" type="button">Clear</button>
      <button class="btn-ghost" type="button" onclick="window.goToNotes()">‚Üê Home</button>
    </div>
  </div>
</section>
<!-- === PAGE: RESERVE END === -->

<!-- === SCRIPTS: RESERVE START === -->
<script>
(function () {
  const $ = (id) => document.getElementById(id);
  const toNum = (v) => {
    const n = parseFloat(v);
    return isFinite(n) ? n : 0;
  };

  // Tank inputs
  const resT1 = $("resT1"),
        resT2 = $("resT2"),
        resT3 = $("resT3"),
        resT4 = $("resT4");

  let maxSCF = 0;

  /* ----------------------------------------
     UPDATE BUTTON ‚Äî POUNDS ‚Üí SCF or SCF direct
  -----------------------------------------*/
  window.calcReserve = function() {
    const amt = toNum($("resAmount").value);
    const type = $("resInputType").value;
    const gasKey = $("resGas").value;
    const gas = window.gases?.[gasKey];

    if (!amt || !gas) {
      $("resHint").textContent = "";
      $("resRemaining").value = 0;
      maxSCF = 0;
      return;
    }

    let scf = 0;

    if (type === "POUNDS") {
      scf = amt * gas.scfPerLb;
    } else {
      scf = amt; // user entered SCF directly
    }

    maxSCF = Math.min(999999, Math.round(scf));

    $("resHint").textContent = `Total SCF: ${maxSCF.toLocaleString()}`;
    $("resRemaining").value = maxSCF.toLocaleString();

    recomputeRemaining();
  };

  $("resUpdate").addEventListener("click", window.calcReserve);

  /* ----------------------------------------
     RECOMPUTE REMAINING SCF (4 tanks)
  -----------------------------------------*/
  function recomputeRemaining(lastChanged) {
    const t1 = toNum(resT1.value);
    const t2 = toNum(resT2.value);
    const t3 = toNum(resT3.value);
    const t4 = toNum(resT4.value);

    let used = t1 + t2 + t3 + t4;

    if (maxSCF > 0 && used > maxSCF && lastChanged) {
      const others = used - toNum(lastChanged.value);
      const allow = Math.max(0, maxSCF - others);
      lastChanged.value = allow;
      used = others + allow;
    }

    let remain = Math.max(0, maxSCF - used);
    $("resRemaining").value = remain.toLocaleString();

    updateTruckInches(remain);
  }

  [resT1, resT2, resT3, resT4].forEach((el) => {
    el.addEventListener("input", (e) => {
      if (toNum(e.target.value) < 0) e.target.value = 0;
      recomputeRemaining(e.target);
    });
  });

  /* ----------------------------------------
     TRUCK INCHES CALC
  -----------------------------------------*/
  function updateTruckInches(remaining) {
    const full = toNum($("resTruckFullIn").value);
    if (!full || maxSCF <= 0) {
      $("resTruckRemainIn").value = "";
      return;
    }

    const ratio = remaining / maxSCF;
    $("resTruckRemainIn").value = Math.round(full * ratio);
  }

  $("resTruckFullIn").addEventListener("input", () => recomputeRemaining());

  /* ----------------------------------------
     CLEAR ALL
  -----------------------------------------*/
  $("resClear").addEventListener("click", () => {
    ["resAmount", "resT1", "resT2", "resT3", "resT4", "resTruckFullIn"]
      .forEach((id) => ($(id).value = ""));

    $("resTruckRemainIn").value = "";
    $("resHint").textContent = "";
    $("resRemaining").value = "0";
    maxSCF = 0;
  });

})();
</script>
<!-- === SCRIPTS: RESERVE END === -->

    <!-- === SCRIPTS: TESTS START === -->
    <script>
      /* Minimal inline tests (run with ?test=1) */
      (function () {
        if (!/([?&])test=1(?!\d)/.test(location.search)) return;
        console.log("[TEST] Starting UI nav tests");
        try {
          console.assert(typeof window.goToNotes === "function", "goToNotes should be a function");
          console.assert(typeof window.goToCalc === "function", "goToCalc should be a function");
          console.assert(typeof window.goToSplit === "function", "goToSplit should be a function");
          console.assert(typeof window.goToReserve === "function", "goToReserve should be a function");
          window.goToCalc();
          setTimeout(() => {
            console.assert(document.getElementById("panes").getAttribute("data-index") === "1", "Should be on Calc pane");
            window.goToSplit();
            setTimeout(() => {
              console.assert(document.getElementById("panes").getAttribute("data-index") === "2", "Should be on Split pane");
              window.goToReserve();
              setTimeout(() => {
                console.assert(document.getElementById("panes").getAttribute("data-index") === "3", "Should be on Reserve pane");
                window.goToNotes();
                setTimeout(() => {
                  console.assert(document.getElementById("panes").getAttribute("data-index") === "0", "Should be on Notes pane");
                  console.log("[TEST] Navigation tests passed");
                }, 50);
              }, 50);
            }, 50);
          }, 50);
        } catch (e) {
          console.error("[TEST] Failed", e);
        }
      })();
    </script>
    <!-- === SCRIPTS: TESTS END === -->
    <!-- === SCRIPTS: NAV (Swipe + Buttons) START === -->
    <script>
      (function () {
        const panes = document.getElementById("panes");
        const viewport = document.getElementById("viewport");
        const dots = [document.getElementById("d0"), document.getElementById("d1"), document.getElementById("d2"), document.getElementById("d3")];

        let index = Number(panes?.dataset.index || 0);

        function setIndex(i) {
          index = Math.max(0, Math.min(3, i));
          if (panes) panes.setAttribute("data-index", String(index));
          dots.forEach((d, k) => {
            if (d) d.classList.toggle("active", k === index);
          });
        }

        // Expose for buttons
        window.goToNotes = () => setIndex(0);
        window.goToCalc = () => setIndex(1);
        window.goToSplit = () => setIndex(2);
        window.goToReserve = () => setIndex(3);

        // Swipe handling
        let startX = 0,
          startY = 0,
          startTime = 0;
        const THRESHOLD = 35; // min X distance
        const RESTRAINT = 80; // max Y drift
        const ALLOWED = 600; // max time (ms)

        viewport?.addEventListener(
          "touchstart",
          (e) => {
            const t = e.changedTouches[0];
            startX = t.pageX;
            startY = t.pageY;
            startTime = Date.now();
          },
          { passive: true }
        );

        viewport?.addEventListener(
          "touchend",
          (e) => {
            const t = e.changedTouches[0];
            const distX = t.pageX - startX;
            const distY = t.pageY - startY;
            const elapsed = Date.now() - startTime;

            if (elapsed <= ALLOWED && Math.abs(distX) >= THRESHOLD && Math.abs(distY) <= RESTRAINT) {
              if (distX < 0) setIndex(index + 1); // swipe left ‚Üí next pane
              else setIndex(index - 1); // swipe right ‚Üí prev pane
            }
          },
          { passive: true }
        );

        // Keyboard support
        document.addEventListener("keydown", (e) => {
          if (e.key === "ArrowLeft") setIndex(index - 1);
          if (e.key === "ArrowRight") setIndex(index + 1);
        });

        // Initialize
        setIndex(index);
      })();
    </script>
    <!-- === SCRIPTS: NAV (Swipe + Buttons) END === -->

    <!-- === SCRIPTS: LOCALSTORAGE PERSISTENCE START === -->
    <script>
      (function () {
        const STORAGE_PREFIX = "cryoCalc_";

        // List of all form fields to persist (ID-based)
        const PERSIST_FIELDS = [
          // Calculator pane
          "tankType",
          "fullInches",
          "geoDiameter",
          "geoLength",
          "fullCap",
          "capUnit",
          "gas",
          "startInches",
          "endInches",
          "startPsi",
          "endPsi",
          "flowValue",
          "meteredScf",
          "chkEstimateD",
          "useTimerPrimary",
          // Split pane
          "totalScf",
          "t1unit",
          "t1Cap",
          "t1s",
          "t1e",
          "t2unit",
          "t2Cap",
          "t2s",
          "t2e",
          // Reserve pane
          "resGallons",
          "resGas",
          "resTruckFullIn",
          "resT1",
          "resT2",
          "resT3",
        ];

        // Save value to localStorage
        function saveField(id, value) {
          try {
            localStorage.setItem(STORAGE_PREFIX + id, value);
          } catch (e) {
            console.warn("localStorage save failed for", id, e);
          }
        }

        // Load value from localStorage
        function loadField(id) {
          try {
            return localStorage.getItem(STORAGE_PREFIX + id);
          } catch (e) {
            console.warn("localStorage load failed for", id, e);
            return null;
          }
        }

        // Clear all persisted fields
        function clearAllFields() {
          PERSIST_FIELDS.forEach((id) => {
            try {
              localStorage.removeItem(STORAGE_PREFIX + id);
            } catch (e) {}
          });
        }

        // Initialize persistence for all fields
        PERSIST_FIELDS.forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;

          // Load saved value on page load
          const saved = loadField(id);
          if (saved !== null) {
            if (el.type === "checkbox") {
              el.checked = saved === "true";
            } else {
              el.value = saved;
            }
            // Trigger change event to update any dependent UI
            el.dispatchEvent(new Event("change", { bubbles: true }));
          }

          // Save on change
          const saveHandler = () => {
            if (el.type === "checkbox") {
              saveField(id, el.checked ? "true" : "false");
            } else {
              saveField(id, el.value);
            }
          };

          el.addEventListener("input", saveHandler);
          el.addEventListener("change", saveHandler);
        });

        // Special handling for unitSwitch toggle
        const unitSwitch = document.getElementById("unitSwitch");
        if (unitSwitch) {
          const savedUnit = loadField("unitSwitch");
          if (savedUnit === "on") {
            unitSwitch.classList.add("on");
            unitSwitch.setAttribute("aria-checked", "true");
          }

          // Save when toggled (assuming there's a click handler already defined)
          const observer = new MutationObserver(() => {
            saveField("unitSwitch", unitSwitch.classList.contains("on") ? "on" : "off");
          });
          observer.observe(unitSwitch, { attributes: true, attributeFilter: ["class"] });
        }

        // Hook into Clear buttons to also clear localStorage
        const clearBtn = document.querySelector("#pane-calc button.btn-clear");
        if (clearBtn) {
          const originalClearHandler = clearBtn.onclick;
          clearBtn.addEventListener("click", () => {
            // Clear calculator-related localStorage
            [
              "tankType",
              "fullInches",
              "geoDiameter",
              "geoLength",
              "fullCap",
              "capUnit",
              "gas",
              "startInches",
              "endInches",
              "flowValue",
              "chkEstimateD",
              "useTimerPrimary",
              "unitSwitch",
            ].forEach((id) => {
              try {
                localStorage.removeItem(STORAGE_PREFIX + id);
              } catch (e) {}
            });
          });
        }

        const clearSplitBtn = document.getElementById("clearSplit");
        if (clearSplitBtn) {
          clearSplitBtn.addEventListener("click", () => {
            ["totalScf", "t1unit", "t1Cap", "t1s", "t1e", "t2unit", "t2Cap", "t2s", "t2e"].forEach((id) => {
              try {
                localStorage.removeItem(STORAGE_PREFIX + id);
              } catch (e) {}
            });
          });
        }

        const resClearBtn = document.getElementById("resClear");
        if (resClearBtn) {
          resClearBtn.addEventListener("click", () => {
            ["resGallons", "resGas", "resTruckFullIn", "resT1", "resT2", "resT3"].forEach((id) => {
              try {
                localStorage.removeItem(STORAGE_PREFIX + id);
              } catch (e) {}
            });
          });
        }

        // Logout function for all logout buttons
        const handleLogout = () => {
          localStorage.removeItem("cryo_auth");
          // Reload parent window (index.html) to show login modal
          if (window.parent && window.parent !== window) {
            window.parent.location.reload();
          } else {
            window.location.reload();
          }
        };

        // Add logout handler to all logout buttons
        const logoutBtn = document.getElementById("logout");
        const logoutCalcBtn = document.getElementById("logoutCalc");
        const logoutSplitBtn = document.getElementById("logoutSplit");
        const logoutNotesBtn = document.getElementById("logoutNotes");

        if (logoutBtn) logoutBtn.addEventListener("click", handleLogout);
        if (logoutCalcBtn) logoutCalcBtn.addEventListener("click", handleLogout);
        if (logoutSplitBtn) logoutSplitBtn.addEventListener("click", handleLogout);
        if (logoutNotesBtn) logoutNotesBtn.addEventListener("click", handleLogout);
      })();
    </script>
    <!-- === SCRIPTS: LOCALSTORAGE PERSISTENCE END === -->

    <!-- === SCRIPTS: OCR PSI CAPTURE START === -->
    <script>
      (function () {
        // Use Apps Script API endpoint for OCR (API key is hidden server-side)
        // Uses the same API_ENDPOINT from constant.js or inline definition
        const OCR_API_ENDPOINT = typeof API_ENDPOINT !== 'undefined'
          ? API_ENDPOINT
          : "https://script.google.com/macros/s/AKfycbwrb3d-OvJUtUCkvMMnwlFRnFeeE4EQUcFMYykUewWpme8f_0lTSs6DteWwGelBPbGD/exec";

        // DOM Elements
        const modal = document.getElementById('ocrModal');
        const video = document.getElementById('ocrVideo');
        const canvas = document.getElementById('ocrCanvas');
        const placeholder = document.getElementById('ocrPlaceholder');
        const btnCapture = document.getElementById('ocrCapture');
        const btnRetake = document.getElementById('ocrRetake');
        const btnRetakeAlt = document.getElementById('ocrRetakeAlt');
        const btnCancel = document.getElementById('ocrCancel');
        const btnApply = document.getElementById('ocrApply');
        const actionsDiv = document.getElementById('ocrActions');
        const loadingDiv = document.getElementById('ocrLoading');
        const resultDiv = document.getElementById('ocrResult');
        const resultValue = document.getElementById('ocrResultValue');

        // State
        let stream = null;
        let targetFieldId = null;
        let capturedImageBase64 = null;
        let detectedValue = null;
        let detectedInches = null;
        let detectedPsi = null;

        // Open modal for a specific field
        window.openOcrModal = function (fieldId) {
          targetFieldId = fieldId;
          modal.classList.add('open');
          resetOcrState();
          // Auto-start camera when modal opens
          startCamera();
        };

        // Reset state
        function resetOcrState() {
          capturedImageBase64 = null;
          detectedValue = null;
          detectedInches = null;
          detectedPsi = null;
          btnCapture.style.display = 'flex';
          btnCapture.disabled = true;
          btnRetake.style.display = 'none';
          actionsDiv.style.display = 'none';
          btnApply.disabled = true;
          loadingDiv.classList.remove('show');
          resultDiv.classList.remove('show', 'error');
          resultValue.textContent = '--';
          placeholder.style.display = 'flex';
          placeholder.textContent = 'Starting camera...';
          canvas.style.display = 'none';
          video.style.display = 'none';
        }

        // Start camera
        async function startCamera() {
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: { ideal: 'environment' } },
              audio: false
            });
            video.srcObject = stream;
            await video.play();
            placeholder.style.display = 'none';
            video.style.display = 'block';
            btnCapture.disabled = false;
          } catch (err) {
            console.error('Camera error:', err);
            placeholder.textContent = 'Camera access denied or unavailable';
          }
        }

        // Stop camera
        function stopCamera() {
          if (stream) {
            stream.getTracks().forEach(t => t.stop());
            stream = null;
          }
          video.srcObject = null;
        }

        // Capture frame and run OCR
        async function captureAndRead() {
          if (!video.videoWidth) return;

          // Draw video frame to canvas
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);

          // Get base64 image
          capturedImageBase64 = canvas.toDataURL('image/jpeg', 0.85).split(',')[1];

          // Show captured image
          video.style.display = 'none';
          canvas.style.display = 'block';
          btnCapture.style.display = 'none';
          actionsDiv.style.display = 'flex';

          // Stop camera to save resources
          stopCamera();

          // Run OCR
          await runOcr();
        }

        // Determine field type based on target field ID
        function getFieldType(fieldId) {
          // Both gauges (inches + PSI from single photo)
          if (fieldId === 'startBoth' || fieldId === 'endBoth' ||
              fieldId === 't1StartBoth' || fieldId === 't1EndBoth' ||
              fieldId === 't2StartBoth' || fieldId === 't2EndBoth') {
            return 'both';
          }
          // PSI fields
          if (fieldId === 'startPsi' || fieldId === 'endPsi' ||
              fieldId === 't1StartPsi' || fieldId === 't1EndPsi' ||
              fieldId === 't2StartPsi' || fieldId === 't2EndPsi') {
            return 'psi';
          }
          // Inches/level fields (large gauge or digital display)
          if (fieldId === 'startInches' || fieldId === 'endInches' ||
              fieldId === 'fullInches' ||
              fieldId === 't1StartInches' || fieldId === 't1EndInches' ||
              fieldId === 't2StartInches' || fieldId === 't2EndInches') {
            return 'level';
          }
          // Totalizer/meter reading (truck flow meter)
          if (fieldId === 'meteredScf') {
            return 'totalizer';
          }
          // Default to level for unknown fields
          return 'level';
        }

        // Run OCR via Apps Script API (Gemini API key hidden server-side)
        async function runOcr() {
          loadingDiv.classList.add('show');
          resultDiv.classList.remove('show', 'error');

          // Determine the correct field type for OCR
          const fieldType = getFieldType(targetFieldId);
          console.log('OCR field type:', fieldType, 'for field:', targetFieldId);

          try {
            // Simple fetch - Apps Script handles JSON body
            const response = await fetch(OCR_API_ENDPOINT, {
              method: 'POST',
              headers: {
                'Content-Type': 'text/plain'
              },
              body: JSON.stringify({
                action: 'ocr',
                image: capturedImageBase64,
                fieldType: fieldType
              })
            });

            const data = await response.json();
            console.log('OCR API response:', data);

            loadingDiv.classList.remove('show');

            // Handle 'both' field type - returns inches and psi separately
            if (fieldType === 'both') {
              if (data.ok && (data.inches !== null || data.psi !== null)) {
                detectedInches = data.inches;
                detectedPsi = data.psi;
                detectedValue = null; // Clear single value
                resultDiv.classList.add('show');
                resultDiv.classList.remove('error');
                // Show different message for digital meter (inches only) vs both gauges
                if (data.inches !== null && data.psi === null) {
                  // Digital meter like Bulk Asset Monitor - shows inches only
                  resultValue.textContent = `Inches: ${data.inches} (enter PSI manually)`;
                } else {
                  const inchesText = data.inches !== null ? data.inches : '-';
                  const psiText = data.psi !== null ? data.psi : '-';
                  resultValue.textContent = `Inches: ${inchesText} | PSI: ${psiText}`;
                }
                btnApply.disabled = false;
              } else {
                resultDiv.classList.add('show', 'error');
                resultValue.textContent = data.error || 'Could not read gauges. Make sure gauges are visible in the photo.';
                btnApply.disabled = true;
              }
              return;
            }

            // Handle single value response
            if (data.ok && data.value !== undefined) {
              detectedValue = data.value;
              detectedInches = null;
              detectedPsi = null;
              resultDiv.classList.add('show');
              resultDiv.classList.remove('error');
              resultValue.textContent = detectedValue;
              btnApply.disabled = false;
            } else {
              resultDiv.classList.add('show', 'error');
              const gaugeType = fieldType === 'psi' ? 'PSI gauge' : 'level gauge';
              resultValue.textContent = data.error || `Could not read ${gaugeType}. Please retake the photo with the gauge clearly visible.`;
              btnApply.disabled = true;
            }
          } catch (err) {
            console.error('OCR error:', err);
            loadingDiv.classList.remove('show');
            resultDiv.classList.add('show', 'error');
            resultValue.textContent = err.message || 'OCR failed. Please try again.';
            btnApply.disabled = true;
          }
        }

        // Apply value to target field
        function applyValue() {
          // Handle 'both' field type - fill both inches and psi fields
          if (targetFieldId === 'startBoth') {
            if (detectedInches !== null) {
              const inchField = document.getElementById('startInches');
              if (inchField) {
                inchField.value = detectedInches;
                inchField.dispatchEvent(new Event('input', { bubbles: true }));
                inchField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
            if (detectedPsi !== null) {
              const psiField = document.getElementById('startPsi');
              if (psiField) {
                psiField.value = detectedPsi;
                psiField.dispatchEvent(new Event('input', { bubbles: true }));
                psiField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
          } else if (targetFieldId === 'endBoth') {
            if (detectedInches !== null) {
              const inchField = document.getElementById('endInches');
              if (inchField) {
                inchField.value = detectedInches;
                inchField.dispatchEvent(new Event('input', { bubbles: true }));
                inchField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
            if (detectedPsi !== null) {
              const psiField = document.getElementById('endPsi');
              if (psiField) {
                psiField.value = detectedPsi;
                psiField.dispatchEvent(new Event('input', { bubbles: true }));
                psiField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
          } else if (targetFieldId === 't1StartBoth') {
            if (detectedInches !== null) {
              const inchField = document.getElementById('t1StartInches');
              if (inchField) {
                inchField.value = detectedInches;
                inchField.dispatchEvent(new Event('input', { bubbles: true }));
                inchField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
            if (detectedPsi !== null) {
              const psiField = document.getElementById('t1StartPsi');
              if (psiField) {
                psiField.value = detectedPsi;
                psiField.dispatchEvent(new Event('input', { bubbles: true }));
                psiField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
          } else if (targetFieldId === 't1EndBoth') {
            if (detectedInches !== null) {
              const inchField = document.getElementById('t1EndInches');
              if (inchField) {
                inchField.value = detectedInches;
                inchField.dispatchEvent(new Event('input', { bubbles: true }));
                inchField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
            if (detectedPsi !== null) {
              const psiField = document.getElementById('t1EndPsi');
              if (psiField) {
                psiField.value = detectedPsi;
                psiField.dispatchEvent(new Event('input', { bubbles: true }));
                psiField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
          } else if (targetFieldId === 't2StartBoth') {
            if (detectedInches !== null) {
              const inchField = document.getElementById('t2StartInches');
              if (inchField) {
                inchField.value = detectedInches;
                inchField.dispatchEvent(new Event('input', { bubbles: true }));
                inchField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
            if (detectedPsi !== null) {
              const psiField = document.getElementById('t2StartPsi');
              if (psiField) {
                psiField.value = detectedPsi;
                psiField.dispatchEvent(new Event('input', { bubbles: true }));
                psiField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
          } else if (targetFieldId === 't2EndBoth') {
            if (detectedInches !== null) {
              const inchField = document.getElementById('t2EndInches');
              if (inchField) {
                inchField.value = detectedInches;
                inchField.dispatchEvent(new Event('input', { bubbles: true }));
                inchField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
            if (detectedPsi !== null) {
              const psiField = document.getElementById('t2EndPsi');
              if (psiField) {
                psiField.value = detectedPsi;
                psiField.dispatchEvent(new Event('input', { bubbles: true }));
                psiField.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
          } else if (detectedValue !== null && targetFieldId) {
            // Handle single value
            const field = document.getElementById(targetFieldId);
            if (field) {
              field.value = detectedValue;
              field.dispatchEvent(new Event('input', { bubbles: true }));
              field.dispatchEvent(new Event('change', { bubbles: true }));
            }
          }

          // Save captured image to Cryo Notes thumbnails if applicable
          const notesThumbMap = {
            'notesStartIn': 'notesThumbStartIn',
            'notesStartPsi': 'notesThumbStartPsi',
            'notesEndIn': 'notesThumbEndIn',
            'notesEndPsi': 'notesThumbEndPsi'
          };
          const thumbCanvasId = notesThumbMap[targetFieldId];
          if (thumbCanvasId && canvas.width > 0) {
            const thumbCanvas = document.getElementById(thumbCanvasId);
            if (thumbCanvas) {
              const container = thumbCanvas.parentElement;
              const w = container.clientWidth || 150;
              const h = Math.round(w * 3 / 4);
              thumbCanvas.width = w;
              thumbCanvas.height = h;
              const tctx = thumbCanvas.getContext('2d');
              tctx.clearRect(0, 0, w, h);
              // Draw captured image (from OCR canvas) to thumbnail
              const scale = Math.min(w / canvas.width, h / canvas.height);
              const dw = canvas.width * scale;
              const dh = canvas.height * scale;
              const dx = (w - dw) / 2;
              const dy = (h - dh) / 2;
              tctx.drawImage(canvas, dx, dy, dw, dh);
            }
          }

          closeModal();
        }

        // Close modal
        function closeModal() {
          modal.classList.remove('open');
          stopCamera();
          resetOcrState();
        }

        // Retake photo
        function retake() {
          canvas.style.display = 'none';
          btnCapture.style.display = 'flex';
          actionsDiv.style.display = 'none';
          resultDiv.classList.remove('show', 'error');
          btnApply.disabled = true;
          startCamera();
        }

        // Event listeners
        btnCapture.addEventListener('click', captureAndRead);
        btnRetake.addEventListener('click', retake);
        if (btnRetakeAlt) btnRetakeAlt.addEventListener('click', retake);
        btnCancel.addEventListener('click', closeModal);
        btnApply.addEventListener('click', applyValue);

        // Note: Removed backdrop click to close since modal is full screen
        // User must use the Close button or Escape key

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && modal.classList.contains('open')) {
            closeModal();
          }
        });
      })();
    </script>
    <!-- === SCRIPTS: OCR PSI CAPTURE END === -->

    <!-- === SCRIPTS: CRYO NOTES START === -->
    <script>
      (function() {
        // Gas conversion constants
        const NOTES_GASES = {
          LIN:  { SCF_PER_GAL: 93.11,  LB_PER_GAL: 6.747 },
          LOX:  { SCF_PER_GAL: 115.1,  LB_PER_GAL: 9.528 },
          LAR:  { SCF_PER_GAL: 112.92, LB_PER_GAL: 11.63 },
          LCO2: { SCF_PER_GAL: 73.94,  LB_PER_GAL: 8.46  },
        };

        // Helper functions
        function num(v) { return (v === "" || v === null || v === undefined) ? NaN : Number(v); }

        // DOM elements
        const els = {
          gasSelect: document.getElementById("notesGasSelect"),
          tankId: document.getElementById("notesTankId"),
          startIn: document.getElementById("notesStartIn"),
          startPsi: document.getElementById("notesStartPsi"),
          endIn: document.getElementById("notesEndIn"),
          endPsi: document.getElementById("notesEndPsi"),
          meteredScf: document.getElementById("notesMeteredScf"),
          meterScale: document.getElementById("notesMeterScale"),
          summaryBox: document.getElementById("notesSummaryBox"),
          convValue: document.getElementById("notesConvValue"),
          convGas: document.getElementById("notesConvGas"),
          fromUnit: document.getElementById("notesFromUnit"),
          toUnit: document.getElementById("notesToUnit"),
          convertBox: document.getElementById("notesConvertBox"),
        };

        // Compute Summary Function (reusable)
        function computeNotesSummary() {
          const gas = els.gasSelect?.value || "LIN";
          const tankId = els.tankId?.value?.trim() || "(blank)";
          const startInches = num(els.startIn?.value);
          const endInches = num(els.endIn?.value);
          const startPsi = num(els.startPsi?.value) || 0;
          const endPsi = num(els.endPsi?.value) || 0;
          const meteredDisplayed = num(els.meteredScf?.value);
          const meterScale = Number(els.meterScale?.value) || 1;

          let meterHtml = "";
          if (Number.isFinite(meteredDisplayed)) {
            const meteredActual = meteredDisplayed * meterScale;
            meterHtml = `
Meter-derived:
  Displayed SCF: ${meteredDisplayed}
  Scale: x${meterScale}
  Actual SCF: ${meteredActual.toFixed(2)}`;
          } else {
            meterHtml = `
Meter-derived:
  Meter SCF missing.`;
          }

          els.summaryBox.innerHTML = `<pre style="margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 14px; line-height: 1.5;">FIELD SUMMARY
Gas: ${gas}
Tank ID: ${tankId}
Start Inches (stored): ${startInches || 0}
End Inches (stored): ${endInches || 0}

PSI (stored): Start PSI=${startPsi} | End PSI=${endPsi}
${meterHtml}</pre>`;
        }

        // Compute Summary button
        document.getElementById("notesComputeBtn")?.addEventListener("click", computeNotesSummary);

        // Clear
        document.getElementById("notesClearBtn")?.addEventListener("click", () => {
          if (els.tankId) els.tankId.value = "";
          if (els.startIn) els.startIn.value = "0";
          if (els.startPsi) els.startPsi.value = "0";
          if (els.endIn) els.endIn.value = "0";
          if (els.endPsi) els.endPsi.value = "0";
          if (els.meteredScf) els.meteredScf.value = "";
          if (els.meterScale) els.meterScale.value = "1";
          if (els.summaryBox) els.summaryBox.textContent = "Summary will appear here‚Ä¶";
          if (els.convValue) els.convValue.value = "";
          if (els.convertBox) els.convertBox.textContent = "Enter a value and choose FROM/TO units‚Ä¶";

          // Clear localStorage for Cryo Notes
          localStorage.removeItem("cryoNotesData");
        });

        // Save to Excel sheet (cryo_notes)
        document.getElementById("notesSaveBtn")?.addEventListener("click", async () => {
          // API endpoint (same as main calculator)
          const NOTES_API_ENDPOINT = "https://script.google.com/macros/s/AKfycbwrb3d-OvJUtUCkvMMnwlFRnFeeE4EQUcFMYykUewWpme8f_0lTSs6DteWwGelBPbGD/exec";

          // Get auth from localStorage (same as getAuth function)
          let auth = null;
          try {
            auth = JSON.parse(localStorage.getItem("cryo_auth") || "null");
          } catch (e) {
            auth = null;
          }

          const notesSaveBtn = document.getElementById("notesSaveBtn");

          if (!auth || !auth.token) {
            alert("Please login to save records.\n\nReload the app and login with your credentials.");
            return;
          }

          // Compute and display summary first
          computeNotesSummary();

          // Collect field values
          const gas = els.gasSelect?.value || "";
          const tank_id = els.tankId?.value?.trim() || "";
          const start_inches = els.startIn?.value || "";
          const starting_psi = els.startPsi?.value || "";
          const end_inches = els.endIn?.value || "";
          const ending_psi = els.endPsi?.value || "";
          const metered_scf = els.meteredScf?.value || "";
          const meter_scale = els.meterScale?.value || "1";

          // Validate - at least tank_id should be filled
          if (!tank_id) {
            alert("Please enter a Tank ID before saving.");
            return;
          }

          // Build single-line result_text for storage (like other calculators)
          let resultText = `Gas: ${gas} ‚Ä¢ Tank ID: ${tank_id} ‚Ä¢ Start Inches: ${start_inches || 0} ‚Ä¢ End Inches: ${end_inches || 0} ‚Ä¢ PSI: Start=${starting_psi || 0} | End=${ending_psi || 0}`;
          if (metered_scf) {
            resultText += ` ‚Ä¢ Metered SCF: ${metered_scf} (Scale: x${meter_scale})`;
          }

          // Build record object matching Excel sheet columns
          const record = {
            gas: gas,
            tank_id: tank_id,
            start_inches: start_inches,
            starting_psi: starting_psi,
            end_inches: end_inches,
            ending_psi: ending_psi,
            metered_scf: metered_scf,
            meter_scale: meter_scale,
            result_text: resultText,
            timestamp: new Date().toISOString()
          };

          // Disable button and show loading
          notesSaveBtn.disabled = true;
          notesSaveBtn.textContent = "Saving...";

          try {
            const response = await fetch(NOTES_API_ENDPOINT, {
              method: "POST",
              headers: {
                "Content-Type": "text/plain"
              },
              body: JSON.stringify({
                action: "save",
                type: "cryo_notes",
                token: auth.token,
                record: record
              }),
              redirect: "follow"
            });

            const data = await response.json();

            if (data.ok) {
              alert("‚úì Cryo Notes saved successfully!");
            } else {
              alert("Save failed: " + (data.error || "Unknown error"));
            }
          } catch (err) {
            console.error("Save error:", err);
            alert("Network error. Please check your connection.");
          } finally {
            notesSaveBtn.disabled = false;
            notesSaveBtn.textContent = "üíæ Save";
          }
        });

        // Records - placeholder
        document.getElementById("notesRecordsBtn")?.addEventListener("click", () => {
          window.location.href = 'records.html?t=' + Date.now();
        });

        // Unit Conversion
        document.getElementById("notesConvertBtn")?.addEventListener("click", () => {
          const gas = els.convGas?.value || "LIN";
          const fromUnit = els.fromUnit?.value || "SCF";
          const toUnit = els.toUnit?.value || "GAL";
          const inputVal = num(els.convValue?.value);
          const cfg = NOTES_GASES[gas];

          if (!Number.isFinite(inputVal)) {
            els.convertBox.innerHTML = `<pre style="margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 14px; line-height: 1.5;">ERROR: Please enter a valid number.</pre>`;
            return;
          }

          if (fromUnit === toUnit) {
            els.convertBox.innerHTML = `<pre style="margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 14px; line-height: 1.5;">FROM and TO are the same unit.
Result: ${inputVal} ${toUnit}</pre>`;
            return;
          }

          // Convert to gallons first (base unit)
          let gallons;
          if (fromUnit === "GAL") gallons = inputVal;
          else if (fromUnit === "SCF") gallons = inputVal / cfg.SCF_PER_GAL;
          else if (fromUnit === "LB") gallons = inputVal / cfg.LB_PER_GAL;

          // Convert from gallons to target
          let outputVal;
          if (toUnit === "GAL") outputVal = gallons;
          else if (toUnit === "SCF") outputVal = gallons * cfg.SCF_PER_GAL;
          else if (toUnit === "LB") outputVal = gallons * cfg.LB_PER_GAL;

          els.convertBox.innerHTML = `<pre style="margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 14px; line-height: 1.5;">CONVERSION
  Gas: ${gas}
  FROM: ${inputVal} ${fromUnit}
  TO:   ${outputVal.toFixed(6)} ${toUnit}

REFERENCE CONSTANTS
  SCF/gal: ${cfg.SCF_PER_GAL}
  lb/gal:  ${cfg.LB_PER_GAL}</pre>`;
        });

        // Swap Units
        document.getElementById("notesSwapUnitsBtn")?.addEventListener("click", () => {
          const from = els.fromUnit?.value;
          els.fromUnit.value = els.toUnit?.value;
          els.toUnit.value = from;
        });

        // Clear Convert
        document.getElementById("notesConvertClearBtn")?.addEventListener("click", () => {
          if (els.convValue) els.convValue.value = "";
          if (els.convertBox) els.convertBox.textContent = "Enter a value and choose FROM/TO units‚Ä¶";
        });

        // Clear gage thumbnails when Clear button is clicked
        const thumbCanvases = [
          document.getElementById("notesThumbStartIn"),
          document.getElementById("notesThumbStartPsi"),
          document.getElementById("notesThumbEndIn"),
          document.getElementById("notesThumbEndPsi")
        ];
        document.getElementById("notesClearBtn")?.addEventListener("click", () => {
          thumbCanvases.forEach(canvas => {
            if (canvas) {
              const ctx = canvas.getContext("2d");
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
          });
        });

        // Gage Images Toggle functionality
        const gageToggle = document.getElementById("notesGageToggle");
        const gageToggleTrack = document.getElementById("notesGageToggleTrack");
        const gageToggleKnob = document.getElementById("notesGageToggleKnob");
        const gageDesc = document.getElementById("notesGageDesc");
        const gageThumbs = document.getElementById("notesGageThumbs");

        function updateGageToggleVisuals(isChecked) {
          if (gageToggleTrack) {
            gageToggleTrack.style.background = isChecked ? "#3b82f6" : "#cbd5e1";
          }
          if (gageToggleKnob) {
            gageToggleKnob.style.transform = isChecked ? "translateX(20px)" : "translateX(0)";
          }
          if (gageDesc) {
            gageDesc.style.display = isChecked ? "block" : "none";
          }
          if (gageThumbs) {
            gageThumbs.style.display = isChecked ? "flex" : "none";
          }
        }

        // Initialize toggle state (checked by default)
        if (gageToggle) {
          updateGageToggleVisuals(gageToggle.checked);
          gageToggle.addEventListener("change", () => {
            updateGageToggleVisuals(gageToggle.checked);
          });
        }

        /* -------------------------------------------
           SESSION STORAGE: Cryo Notes
        -------------------------------------------- */
        const notesFields = [
          "notesGasSelect", "notesTankId", "notesStartIn", "notesStartPsi",
          "notesEndIn", "notesEndPsi", "notesMeteredScf", "notesMeterScale",
          "notesConvValue", "notesConvGas", "notesConvFromUnit", "notesConvToUnit"
        ];

        function saveNotesToSession() {
          const data = {};
          notesFields.forEach(id => {
            const el = document.getElementById(id);
            if (el) data[id] = el.value;
          });
          localStorage.setItem("cryoNotesData", JSON.stringify(data));
        }

        function loadNotesFromSession() {
          const saved = localStorage.getItem("cryoNotesData");
          if (!saved) return;

          try {
            const data = JSON.parse(saved);
            notesFields.forEach(id => {
              const el = document.getElementById(id);
              if (el && data[id] !== undefined && data[id] !== "") {
                el.value = data[id];
              }
            });
          } catch (e) {
            console.error("Error loading cryo notes data:", e);
          }
        }

        function setupNotesAutoSave() {
          notesFields.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
              el.addEventListener("input", saveNotesToSession);
              el.addEventListener("change", saveNotesToSession);
            }
          });
        }

        // Load and setup auto-save for cryo notes
        loadNotesFromSession();
        setupNotesAutoSave();
      })();
    </script>
    <!-- === SCRIPTS: CRYO NOTES END === -->

    <!-- Copyright Notice -->
    <div style="position: fixed; bottom: 10px; left: 0; right: 0; text-align: center; color: rgba(255, 255, 255, 0.9); font-size: 11px; pointer-events: none; z-index: 9998;">
      <div style="display: inline-block; background: rgba(0, 0, 0, 0.7); padding: 6px 16px; border-radius: 6px;">
        ¬© 2025 RMC Squared Inc. All Rights Reserved.
      </div>
    </div>
  </body>
</html>
