// Apps Script Code (single file: Code.gs)
/************************************************************
 * Cryo Calculator - Google Sheets Backend (Apps Script)
 * Endpoints:
 *   GET  ?action=ping
 *   POST { action:"login", email, password }
 *   POST { action:"save", type:"calc|split|reserve|cryo_notes", token, record:{} }
 *   POST { action:"fetch", type:"calc|split|reserve|cryo_notes|all", token, limit }
 *
 * Deployment:
 *   Deploy as Web App:
 *     - Execute as: Me
 *     - Who has access: Anyone with the link
 ************************************************************/

/** ====== CONFIG ====== **/
const CONFIG = {
  // If this script is bound to the spreadsheet, you can leave SHEET_ID blank.
  SHEET_ID: "",

  // REQUIRED: change this to a long random string.
  TOKEN_SECRET: "mySecretKey_2024_xyz789abc123def456ghi789jkl012mno345pqr678stu901vwx234",

  // Session duration
  TOKEN_TTL_SECONDS: 60 * 60 * 24 * 7, // 7 days

  // Gemini API Key for OCR
  GEMINI_API_KEY: "AIzaSyCQuNf48yYC7ylH8xst51bgGq_fwg-Zjhs",

  // Resend API Key for password reset emails
  RESEND_API_KEY: "re_WZHvj7Cf_FdaDqgkHyzYo5rAuRgsSGi1e",

  // Password reset token expiry (15 minutes)
  RESET_TOKEN_TTL_SECONDS: 60 * 15,

  // App URLs for reset links
  APP_URLS: {
    LOCALHOST: "http://127.0.0.1:8080",
    PRODUCTION: "https://cryocalculator.com"
  },

  // Sheet names
  SHEETS: {
    USERS: "users",
    CALC: "calc_records",
    SPLIT: "split_records",
    RESERVE: "reserve_records",
    CRYO_NOTES: "cryo_notes",
    RESET_TOKENS: "reset_tokens", // for password reset tokens
    AUDIT: "audit_log" // optional
  }
};
/** ====== ROUTING ====== **/
/**
 * doGet handles all GET requests including CORS preflight workaround.
 *
 * IMPORTANT: Google Apps Script Web Apps do NOT support:
 * - Custom response headers (no Access-Control-Allow-Origin)
 * - OPTIONS method (doOptions is never called)
 *
 * SOLUTION: All requests must go through doGet or doPost.
 * For CORS to work, deploy with "Anyone" access (not "Anyone with link").
 *
 * If you still get CORS errors, use the JSONP callback parameter:
 * GET ?action=ping&callback=myCallback
 * Returns: myCallback({"ok":true,...})
 */
function doGet(e) {
  const params = (e && e.parameter) ? e.parameter : {};
  const action = params.action || "ping";
  const callback = params.callback || null; // JSONP support

  try {
    let result;

    switch (action) {
      case "ping":
        result = { ok: true, service: "cryo-sheets-api", time: new Date().toISOString() };
        break;

      case "login":
        // Support GET-based login for CORS workaround
        result = handleLoginGet_(params);
        break;

      case "fetch":
        // Support GET-based fetch for CORS workaround
        result = handleFetchGet_(params);
        break;

      default:
        result = { ok: false, error: "Invalid GET action. Valid: ping, login, fetch", status: 400 };
    }

    // JSONP support - wrap response in callback function
    if (callback) {
      return ContentService
        .createTextOutput(callback + "(" + JSON.stringify(result) + ");")
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
    }

    return jsonResponse(result, result.status);
  } catch (err) {
    const errorResult = { ok: false, error: String(err), status: 500 };
    if (callback) {
      return ContentService
        .createTextOutput(callback + "(" + JSON.stringify(errorResult) + ");")
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
    }
    return jsonResponse(errorResult, 500);
  }
}

/**
 * Handle login via GET parameters (CORS workaround)
 * GET ?action=login&email=x&password=y
 */
function handleLoginGet_(params) {
  const body = {
    email: params.email || "",
    password: params.password || ""
  };
  // Reuse POST handler logic
  return handleLogin_(body, true); // true = return object instead of ContentService
}

/**
 * Handle fetch via GET parameters (CORS workaround)
 * GET ?action=fetch&token=x&type=calc&limit=50
 */
function handleFetchGet_(params) {
  const body = {
    token: params.token || "",
    type: params.type || "all",
    limit: params.limit || 100
  };
  return handleFetch_(body, true); // true = return object instead of ContentService
}

function doPost(e) {
  try {
    const body = parseJsonBody_(e);
    const action = body.action;
    const callback = body.callback || null; // JSONP support for POST too

    if (!action) {
      const err = { ok: false, error: "Missing action", status: 400 };
      return callback ? jsonpResponse(callback, err) : jsonResponse(err, 400);
    }

    let result;
    switch (action) {
      case "login":
        result = handleLogin_(body, true);
        break;

      case "save":
        result = handleSave_(body, true);
        break;

      case "fetch":
        result = handleFetch_(body, true);
        break;

      case "register":
        result = handleRegister_(body, true);
        break;

      case "delete":
        result = handleDelete_(body, true);
        break;

      case "deleteBulk":
        result = handleDeleteBulk_(body, true);
        break;

      case "ocr":
        result = handleOcr_(body, true);
        break;

      case "requestReset":
        result = handleRequestReset_(body, true);
        break;

      case "resetPassword":
        result = handleResetPassword_(body, true);
        break;

      default:
        result = { ok: false, error: "Invalid action", status: 400 };
    }

    return callback ? jsonpResponse(callback, result) : jsonResponse(result, result.status);
  } catch (err) {
    // Log server-side only
    safeAudit_("ERROR", { message: String(err), stack: (err && err.stack) ? err.stack : "" });
    const errResult = { ok: false, error: "Server error", status: 500 };
    return jsonResponse(errResult, 500);
  }
}

/**
 * JSONP response helper
 */
function jsonpResponse(callback, obj) {
  return ContentService
    .createTextOutput(callback + "(" + JSON.stringify(obj) + ");")
    .setMimeType(ContentService.MimeType.JAVASCRIPT);
}

/** ====== LOGIN ====== **/
function handleLogin_(body, returnObject) {
  const email = String(body.email || "").trim().toLowerCase();
  const password = String(body.password || "");

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!email || !password) {
    return respond({ ok: false, error: "Email and password required" }, 400);
  }

  const ss = getSpreadsheet_();
  const usersSheet = ss.getSheetByName(CONFIG.SHEETS.USERS);
  if (!usersSheet) return respond({ ok: false, error: "Missing users sheet" }, 500);

  const { headerMap, rows } = readSheetAsObjects_(usersSheet);
  // Expected columns: user_id, email, password_hash, role, active, created_at
  const user = rows.find(r => String(r.email || "").trim().toLowerCase() === email);

  if (!user) {
    safeAudit_("LOGIN_FAIL", { email, reason: "no_user" });
    return respond({ ok: false, error: "Invalid credentials" }, 401);
  }

  const active = String(user.active || "").toLowerCase();
  if (active === "false" || active === "0" || active === "no") {
    safeAudit_("LOGIN_FAIL", { email, reason: "inactive" });
    return respond({ ok: false, error: "Account disabled" }, 403);
  }

  const passwordHash = sha256Base64_(password);
  if (String(user.password_hash || "") !== passwordHash) {
    safeAudit_("LOGIN_FAIL", { email, reason: "bad_password" });
    return respond({ ok: false, error: "Invalid credentials" }, 401);
  }

  const userId = String(user.user_id || "").trim() || Utilities.getUuid();
  const role = String(user.role || "user").trim() || "user";
  const now = Math.floor(Date.now() / 1000);
  const exp = now + CONFIG.TOKEN_TTL_SECONDS;

  const token = signToken_({
    user_id: userId,
    email,
    role,
    iat: now,
    exp
  });

  safeAudit_("LOGIN_OK", { email, user_id: userId, role });

  return respond({
    ok: true,
    auth: { user_id: userId, email, role, token, exp }
  });
}

/** ====== REGISTER NEW USER ====== **/
function handleRegister_(body, returnObject) {
  const email = String(body.email || "").trim().toLowerCase();
  const password = String(body.password || "");
  const confirmPassword = String(body.confirmPassword || "");

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  // Validate email
  if (!email) {
    return respond({ ok: false, error: "Email is required" }, 400);
  }
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return respond({ ok: false, error: "Invalid email format" }, 400);
  }

  // Validate password
  if (!password) {
    return respond({ ok: false, error: "Password is required" }, 400);
  }
  if (password.length < 6) {
    return respond({ ok: false, error: "Password must be at least 6 characters" }, 400);
  }

  // Validate password confirmation
  if (password !== confirmPassword) {
    return respond({ ok: false, error: "Passwords do not match" }, 400);
  }

  const ss = getSpreadsheet_();
  const usersSheet = ss.getSheetByName(CONFIG.SHEETS.USERS);
  if (!usersSheet) return respond({ ok: false, error: "Missing users sheet" }, 500);

  // Check if email already exists
  const { rows } = readSheetAsObjects_(usersSheet);
  const existingUser = rows.find(r => String(r.email || "").trim().toLowerCase() === email);

  if (existingUser) {
    safeAudit_("REGISTER_FAIL", { email, reason: "duplicate_email" });
    return respond({ ok: false, error: "An account with this email already exists" }, 409);
  }

  // Create new user
  const userId = Utilities.getUuid();
  const passwordHash = sha256Base64_(password);
  const role = "user";
  const createdAt = new Date().toISOString();

  try {
    appendObjectToSheet_(usersSheet, {
      user_id: userId,
      email: email,
      password_hash: passwordHash,
      role: role,
      active: true,
      created_at: createdAt
    });
  } catch (err) {
    safeAudit_("REGISTER_FAIL", { email, reason: "sheet_error", error: String(err) });
    return respond({ ok: false, error: "Failed to create account. Please try again." }, 500);
  }

  // Generate token for immediate login after registration
  const now = Math.floor(Date.now() / 1000);
  const exp = now + CONFIG.TOKEN_TTL_SECONDS;

  const token = signToken_({
    user_id: userId,
    email,
    role,
    iat: now,
    exp
  });

  safeAudit_("REGISTER_OK", { email, user_id: userId });

  return respond({
    ok: true,
    message: "Account created successfully",
    auth: { user_id: userId, email, role, token, exp }
  });
}

/** ====== SAVE RECORDS ====== **/
function handleSave_(body, returnObject) {
  const token = String(body.token || "");
  const type = String(body.type || "").trim().toLowerCase();
  const record = body.record || null;

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!token) return respond({ ok: false, error: "Missing token" }, 401);
  if (!record) return respond({ ok: false, error: "Missing record" }, 400);
  if (!["calc", "split", "reserve", "cryo_notes"].includes(type)) {
    return respond({ ok: false, error: "Invalid record type" }, 400);
  }

  const auth = verifyToken_(token);
  if (!auth.ok) return respond({ ok: false, error: auth.error }, 401);

  const ss = getSpreadsheet_();
  const sheetName =
    type === "calc" ? CONFIG.SHEETS.CALC :
    type === "split" ? CONFIG.SHEETS.SPLIT :
    type === "cryo_notes" ? CONFIG.SHEETS.CRYO_NOTES :
    CONFIG.SHEETS.RESERVE;

  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return respond({ ok: false, error: `Missing sheet: ${sheetName}` }, 500);

  // Ensure required metadata exists
  const rowObj = Object.assign({}, record, {
    record_id: Utilities.getUuid(),
    user_id: auth.payload.user_id,
    timestamp: record.timestamp || new Date().toISOString(),
    source: record.source || "sync"
  });

  // Append row by header order
  appendObjectToSheet_(sheet, rowObj);

  safeAudit_("SAVE_OK", { type, user_id: auth.payload.user_id });

  return respond({ ok: true });
}

/** ====== FETCH RECORDS ====== **/
function handleFetch_(body, returnObject) {
  const token = String(body.token || "");
  const type = String(body.type || "all").trim().toLowerCase();
  const limit = clampInt_(body.limit, 1, 500, 100);

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!token) return respond({ ok: false, error: "Missing token" }, 401);

  const auth = verifyToken_(token);
  if (!auth.ok) return respond({ ok: false, error: auth.error }, 401);

  const ss = getSpreadsheet_();
  const userId = auth.payload.user_id;

  const typesToFetch = (type === "all")
    ? ["calc", "split", "reserve", "cryo_notes"]
    : [type];

  const result = {};

  typesToFetch.forEach(t => {
    if (!["calc", "split", "reserve", "cryo_notes"].includes(t)) return;

    const sheetName =
      t === "calc" ? CONFIG.SHEETS.CALC :
      t === "split" ? CONFIG.SHEETS.SPLIT :
      t === "cryo_notes" ? CONFIG.SHEETS.CRYO_NOTES :
      CONFIG.SHEETS.RESERVE;

    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      result[t] = { ok: false, error: `Missing sheet: ${sheetName}`, records: [] };
      return;
    }

    const { rows } = readSheetAsObjects_(sheet);
    // Filter by user_id
    const mine = rows
      .filter(r => String(r.user_id || "") === userId)
      // Newest first if timestamp exists
      .sort((a, b) => String(b.timestamp || "").localeCompare(String(a.timestamp || "")))
      .slice(0, limit);

    result[t] = { ok: true, records: mine };
  });

  safeAudit_("FETCH_OK", { type, user_id: userId, limit });

  return respond({ ok: true, data: result });
}

/** ====== DELETE RECORDS ====== **/
function handleDelete_(body, returnObject) {
  const token = String(body.token || "");
  const type = String(body.type || "").trim().toLowerCase();
  const recordId = String(body.record_id || "").trim();

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!token) return respond({ ok: false, error: "Missing token" }, 401);
  if (!recordId) return respond({ ok: false, error: "Missing record_id" }, 400);
  if (!["calc", "split", "reserve", "cryo_notes"].includes(type)) {
    return respond({ ok: false, error: "Invalid record type" }, 400);
  }

  const auth = verifyToken_(token);
  if (!auth.ok) return respond({ ok: false, error: auth.error }, 401);

  const ss = getSpreadsheet_();
  const sheetName =
    type === "calc" ? CONFIG.SHEETS.CALC :
    type === "split" ? CONFIG.SHEETS.SPLIT :
    type === "cryo_notes" ? CONFIG.SHEETS.CRYO_NOTES :
    CONFIG.SHEETS.RESERVE;

  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return respond({ ok: false, error: `Missing sheet: ${sheetName}` }, 500);

  const userId = auth.payload.user_id;

  // Find the row to delete
  const { headerMap, rows } = readSheetAsObjects_(sheet);
  const recordIdColIndex = headerMap["record_id"];

  if (recordIdColIndex === undefined) {
    return respond({ ok: false, error: "Sheet missing record_id column" }, 500);
  }

  // Find the row index (1-indexed, add 2 for header row and 0-index offset)
  let rowToDelete = -1;
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    if (String(row.record_id || "") === recordId) {
      // Verify ownership - user can only delete their own records
      if (String(row.user_id || "") !== userId) {
        safeAudit_("DELETE_FAIL", { record_id: recordId, user_id: userId, reason: "unauthorized" });
        return respond({ ok: false, error: "Unauthorized to delete this record" }, 403);
      }
      rowToDelete = i + 2; // +2 for header row (1) and 0-index offset (1)
      break;
    }
  }

  if (rowToDelete === -1) {
    return respond({ ok: false, error: "Record not found" }, 404);
  }

  // Delete the row
  try {
    sheet.deleteRow(rowToDelete);
    safeAudit_("DELETE_OK", { type, record_id: recordId, user_id: userId });
    return respond({ ok: true, message: "Record deleted successfully" });
  } catch (err) {
    safeAudit_("DELETE_FAIL", { record_id: recordId, user_id: userId, error: String(err) });
    return respond({ ok: false, error: "Failed to delete record" }, 500);
  }
}

/** ====== DELETE MULTIPLE RECORDS (BULK) ====== **/
function handleDeleteBulk_(body, returnObject) {
  const token = String(body.token || "");
  const records = body.records || []; // Array of { type, record_id }

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!token) return respond({ ok: false, error: "Missing token" }, 401);
  if (!Array.isArray(records) || records.length === 0) {
    return respond({ ok: false, error: "Missing or empty records array" }, 400);
  }

  const auth = verifyToken_(token);
  if (!auth.ok) return respond({ ok: false, error: auth.error }, 401);

  const ss = getSpreadsheet_();
  const userId = auth.payload.user_id;

  const results = {
    deleted: [],
    failed: []
  };

  // Group records by type for efficiency
  const byType = {};
  records.forEach(r => {
    const type = String(r.type || "").trim().toLowerCase();
    const recordId = String(r.record_id || "").trim();
    if (!type || !recordId) return;
    if (!["calc", "split", "reserve", "cryo_notes"].includes(type)) return;
    if (!byType[type]) byType[type] = [];
    byType[type].push(recordId);
  });

  // Process each type
  Object.keys(byType).forEach(type => {
    const recordIds = byType[type];
    const sheetName =
      type === "calc" ? CONFIG.SHEETS.CALC :
      type === "split" ? CONFIG.SHEETS.SPLIT :
      type === "cryo_notes" ? CONFIG.SHEETS.CRYO_NOTES :
      CONFIG.SHEETS.RESERVE;

    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      recordIds.forEach(id => results.failed.push({ record_id: id, type, error: "Sheet not found" }));
      return;
    }

    const { headerMap, rows } = readSheetAsObjects_(sheet);
    const recordIdColIndex = headerMap["record_id"];

    if (recordIdColIndex === undefined) {
      recordIds.forEach(id => results.failed.push({ record_id: id, type, error: "Missing record_id column" }));
      return;
    }

    // Find rows to delete (collect row numbers in reverse order to avoid shifting issues)
    const rowsToDelete = [];
    recordIds.forEach(recordId => {
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (String(row.record_id || "") === recordId) {
          // Verify ownership
          if (String(row.user_id || "") !== userId) {
            results.failed.push({ record_id: recordId, type, error: "Unauthorized" });
            return;
          }
          rowsToDelete.push({ rowNum: i + 2, recordId, type }); // +2 for header and 0-index
          return;
        }
      }
      results.failed.push({ record_id: recordId, type, error: "Not found" });
    });

    // Delete rows in reverse order (highest row first) to avoid index shifting
    rowsToDelete.sort((a, b) => b.rowNum - a.rowNum);
    rowsToDelete.forEach(item => {
      try {
        sheet.deleteRow(item.rowNum);
        results.deleted.push({ record_id: item.recordId, type: item.type });
      } catch (err) {
        results.failed.push({ record_id: item.recordId, type: item.type, error: String(err) });
      }
    });
  });

  safeAudit_("DELETE_BULK_OK", { user_id: userId, deleted: results.deleted.length, failed: results.failed.length });

  return respond({
    ok: true,
    message: `Deleted ${results.deleted.length} record(s)`,
    deleted: results.deleted,
    failed: results.failed
  });
}

/** ====== OCR (GEMINI API) ====== **/
/**
 * Handle OCR request - extracts PSI value from gauge image
 * POST { action: "ocr", image: "base64_image_data", fieldType: "psi" }
 */
function handleOcr_(body, returnObject) {
  const imageBase64 = String(body.image || "");
  const fieldType = String(body.fieldType || "psi").toLowerCase();

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!imageBase64) {
    return respond({ ok: false, error: "Missing image data" }, 400);
  }

  // Build prompt based on field type
  let prompt;
  switch (fieldType) {
    case "both":
      prompt = `Look at the image and identify what type of gauge/meter is shown:

OPTION A - TWO ANALOG GAUGES stacked vertically:
- LARGE gauge (top): Shows product level in IN.H₂O (inches of water) - scale typically 0-400
- SMALL gauge (bottom): Shows pressure in PSI - scale typically 0-400
If you see two analog gauges, read BOTH values.

OPTION B - DIGITAL METER/DISPLAY (like "Airgas Bulk Asset Monitor"):
- A digital LCD display showing a number
- This represents INCHES (tank level) only - user will enter PSI manually
If you see a digital display, read just the INCHES value.

ANSWER FORMAT:
- If TWO analog gauges: respond with two lines:
  INCHES=123
  PSI=45
- If DIGITAL METER only: respond with two lines:
  INCHES=43
  PSI=MANUAL

(only digits or digits with decimal for values, no units)
If you cannot read a value, use ERROR for that value.`;
      break;

    case "psi":
    case "psi_analog":
      prompt = `You see a SMALL pressure gauge labeled "psi" (typically the smaller gauge, below or beside a larger one). This gauge shows tank pressure in PSI units. The scale typically goes 0-400 PSI with inner bar scale.

Read the current pressure value indicated by the needle on the PSI scale (the outer black numbers, not the inner bar scale).

Answer with exactly one line in this format: VALUE=123
(only digits or digits with decimal, no units, no other text).

If you cannot read the value clearly, respond with: VALUE=ERROR`;
      break;

    case "level":
    case "inches":
      prompt = `You see a LARGE tank level gauge showing product level. This could be:
1. A large analog CHART gauge with "IN.H₂O" (inches of water) scale - typically 0-400 range
2. A digital display (like Airgas Bulk Asset Monitor) showing a number

For analog gauges: Read the value where the needle points on the IN.H₂O scale (inner black numbers, typically 0-400).
For digital displays: Read the number shown on the LCD/LED display.

Answer with exactly one line in this format: VALUE=123
(only digits or digits with decimal, no units, no other text).

If you cannot read the value clearly, respond with: VALUE=ERROR`;
      break;

    case "totalizer":
      prompt = `You see a flow meter or totalizer display. Find and read the LARGE main TOTALIZER value (cumulative total).

Answer with exactly one line in this format: VALUE=123456
(only digits, no units, no other text).

If you cannot read the value clearly, respond with: VALUE=ERROR`;
      break;

    default:
      prompt = `Read the numeric value shown in this gauge or display.

Answer with exactly one line in this format: VALUE=123
(only digits or digits with decimal, no units, no other text).

If you cannot read the value clearly, respond with: VALUE=ERROR`;
  }

  try {
    // Call Gemini API
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${CONFIG.GEMINI_API_KEY}`;

    const payload = {
      contents: [{
        parts: [
          { inline_data: { mime_type: "image/jpeg", data: imageBase64 } },
          { text: prompt }
        ]
      }]
    };

    const options = {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    };

    const response = UrlFetchApp.fetch(apiUrl, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();

    if (responseCode !== 200) {
      safeAudit_("OCR_FAIL", { reason: "api_error", code: responseCode });
      if (responseCode === 429) {
        return respond({ ok: false, error: "API quota exceeded. Please try again later." }, 429);
      }
      if (responseCode === 503) {
        return respond({ ok: false, error: "AI service overloaded. Please retry." }, 503);
      }
      return respond({ ok: false, error: `Gemini API error: ${responseCode}` }, 500);
    }

    const data = JSON.parse(responseText);
    const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "";

    // Handle 'both' field type - returns inches and psi separately
    if (fieldType === "both") {
      const result = parseOcrBothValues_(text);
      if (result.inches !== null || result.psi !== null) {
        safeAudit_("OCR_OK", { fieldType, inches: result.inches, psi: result.psi });
        return respond({ ok: true, inches: result.inches, psi: result.psi, raw: text });
      } else {
        safeAudit_("OCR_FAIL", { reason: "parse_error", raw: text });
        return respond({ ok: false, error: "Could not read gauges from image", raw: text }, 422);
      }
    }

    // Parse single value from response
    const value = parseOcrValue_(text);

    if (value !== null) {
      safeAudit_("OCR_OK", { fieldType, value });
      return respond({ ok: true, value: value, raw: text });
    } else {
      safeAudit_("OCR_FAIL", { reason: "parse_error", raw: text });
      return respond({ ok: false, error: "Could not read value from image", raw: text }, 422);
    }

  } catch (err) {
    safeAudit_("OCR_FAIL", { reason: "exception", error: String(err) });
    return respond({ ok: false, error: "OCR processing failed: " + String(err) }, 500);
  }
}

/** ====== PASSWORD RESET ====== **/
/**
 * Handle password reset request - generates token and sends email via Resend
 * POST { action: "requestReset", email: "user@email.com", origin: "http://..." }
 */
function handleRequestReset_(body, returnObject) {
  const email = String(body.email || "").trim().toLowerCase();
  const origin = String(body.origin || "").trim();

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!email) {
    return respond({ ok: false, error: "Email is required" }, 400);
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return respond({ ok: false, error: "Invalid email format" }, 400);
  }

  const ss = getSpreadsheet_();
  const usersSheet = ss.getSheetByName(CONFIG.SHEETS.USERS);
  if (!usersSheet) return respond({ ok: false, error: "System error" }, 500);

  // Check if user exists
  const { rows } = readSheetAsObjects_(usersSheet);
  const user = rows.find(r => String(r.email || "").trim().toLowerCase() === email);

  // Always return success to prevent email enumeration attacks
  // But only actually send email if user exists
  if (!user) {
    safeAudit_("RESET_REQUEST_FAIL", { email, reason: "no_user" });
    // Return success anyway to prevent enumeration
    return respond({ ok: true, message: "If an account exists with this email, you will receive a reset link." });
  }

  // Generate reset token
  const resetToken = generateResetToken_();
  const expiresAt = new Date(Date.now() + CONFIG.RESET_TOKEN_TTL_SECONDS * 1000).toISOString();

  // Store token in reset_tokens sheet
  const tokensSheet = getOrCreateResetTokensSheet_(ss);

  // Remove any existing tokens for this email (one active token per user)
  clearExistingTokens_(tokensSheet, email);

  // Add new token
  appendObjectToSheet_(tokensSheet, {
    email: email,
    token: resetToken,
    expires_at: expiresAt,
    created_at: new Date().toISOString(),
    used: false
  });

  // Determine the correct base URL
  const baseUrl = determineBaseUrl_(origin);
  const resetLink = `${baseUrl}/reset-password.html?token=${resetToken}&email=${encodeURIComponent(email)}`;

  // Send email via Resend
  const emailResult = sendResetEmail_(email, resetLink);

  if (!emailResult.ok) {
    safeAudit_("RESET_EMAIL_FAIL", { email, error: emailResult.error });
    return respond({ ok: false, error: "Failed to send reset email. Please try again." }, 500);
  }

  safeAudit_("RESET_REQUEST_OK", { email });
  return respond({ ok: true, message: "If an account exists with this email, you will receive a reset link." });
}

/**
 * Handle password reset - validates token and updates password
 * POST { action: "resetPassword", email: "user@email.com", token: "xxx", newPassword: "xxx" }
 */
function handleResetPassword_(body, returnObject) {
  const email = String(body.email || "").trim().toLowerCase();
  const token = String(body.token || "").trim();
  const newPassword = String(body.newPassword || "");

  // Helper to return result based on returnObject flag
  const respond = (obj, status) => {
    obj.status = status || 200;
    return returnObject ? obj : jsonResponse(obj, status);
  };

  if (!email || !token || !newPassword) {
    return respond({ ok: false, error: "Missing required fields" }, 400);
  }

  if (newPassword.length < 6) {
    return respond({ ok: false, error: "Password must be at least 6 characters" }, 400);
  }

  const ss = getSpreadsheet_();

  // Validate token
  const tokensSheet = ss.getSheetByName(CONFIG.SHEETS.RESET_TOKENS);
  if (!tokensSheet) {
    return respond({ ok: false, error: "Invalid or expired reset link" }, 400);
  }

  const { rows: tokenRows } = readSheetAsObjects_(tokensSheet);
  const tokenRecord = tokenRows.find(r =>
    String(r.email || "").trim().toLowerCase() === email &&
    String(r.token || "") === token &&
    String(r.used || "").toLowerCase() !== "true"
  );

  if (!tokenRecord) {
    safeAudit_("RESET_PASSWORD_FAIL", { email, reason: "invalid_token" });
    return respond({ ok: false, error: "Invalid or expired reset link" }, 400);
  }

  // Check if token is expired
  const expiresAt = new Date(tokenRecord.expires_at);
  if (new Date() > expiresAt) {
    safeAudit_("RESET_PASSWORD_FAIL", { email, reason: "expired_token" });
    return respond({ ok: false, error: "Reset link has expired. Please request a new one." }, 400);
  }

  // Update user's password
  const usersSheet = ss.getSheetByName(CONFIG.SHEETS.USERS);
  if (!usersSheet) return respond({ ok: false, error: "System error" }, 500);

  const { headerMap, rows: userRows } = readSheetAsObjects_(usersSheet);
  const passwordColIndex = headerMap["password_hash"];

  if (passwordColIndex === undefined) {
    return respond({ ok: false, error: "System error" }, 500);
  }

  // Find user row and update password
  let userRowNum = -1;
  for (let i = 0; i < userRows.length; i++) {
    if (String(userRows[i].email || "").trim().toLowerCase() === email) {
      userRowNum = i + 2; // +2 for header row and 0-index
      break;
    }
  }

  if (userRowNum === -1) {
    return respond({ ok: false, error: "User not found" }, 400);
  }

  // Update password hash
  const newPasswordHash = sha256Base64_(newPassword);
  usersSheet.getRange(userRowNum, passwordColIndex + 1).setValue(newPasswordHash);

  // Mark token as used
  markTokenAsUsed_(tokensSheet, email, token);

  safeAudit_("RESET_PASSWORD_OK", { email });
  return respond({ ok: true, message: "Password has been reset successfully. You can now login with your new password." });
}

/**
 * Generate a secure random reset token
 */
function generateResetToken_() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let token = '';
  for (let i = 0; i < 64; i++) {
    token += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return token;
}

/**
 * Determine base URL based on request origin
 */
function determineBaseUrl_(origin) {
  if (!origin) return CONFIG.APP_URLS.PRODUCTION;

  // Check if request is from localhost
  if (origin.includes('127.0.0.1') || origin.includes('localhost')) {
    return CONFIG.APP_URLS.LOCALHOST;
  }

  return CONFIG.APP_URLS.PRODUCTION;
}

/**
 * Get or create reset_tokens sheet
 */
function getOrCreateResetTokensSheet_(ss) {
  let sheet = ss.getSheetByName(CONFIG.SHEETS.RESET_TOKENS);
  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.SHEETS.RESET_TOKENS);
    // Add headers
    sheet.getRange(1, 1, 1, 5).setValues([["email", "token", "expires_at", "created_at", "used"]]);
  }
  return sheet;
}

/**
 * Clear existing tokens for an email
 */
function clearExistingTokens_(tokensSheet, email) {
  const { rows } = readSheetAsObjects_(tokensSheet);
  // Delete rows in reverse order to avoid index shifting
  const rowsToDelete = [];
  for (let i = 0; i < rows.length; i++) {
    if (String(rows[i].email || "").trim().toLowerCase() === email) {
      rowsToDelete.push(i + 2); // +2 for header and 0-index
    }
  }
  rowsToDelete.reverse().forEach(rowNum => {
    tokensSheet.deleteRow(rowNum);
  });
}

/**
 * Mark a token as used
 */
function markTokenAsUsed_(tokensSheet, email, token) {
  const { headerMap, rows } = readSheetAsObjects_(tokensSheet);
  const usedColIndex = headerMap["used"];

  if (usedColIndex === undefined) return;

  for (let i = 0; i < rows.length; i++) {
    if (String(rows[i].email || "").trim().toLowerCase() === email &&
        String(rows[i].token || "") === token) {
      tokensSheet.getRange(i + 2, usedColIndex + 1).setValue(true);
      break;
    }
  }
}

/**
 * Send password reset email via Resend API
 */
function sendResetEmail_(toEmail, resetLink) {
  const apiUrl = "https://api.resend.com/emails";

  const emailHtml = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
      <h2 style="color: #003366;">Reset Your Password</h2>
      <p>You requested to reset your password for Cryo Calculator.</p>
      <p>Click the button below to reset your password. This link will expire in 15 minutes.</p>
      <div style="text-align: center; margin: 30px 0;">
        <a href="${resetLink}"
           style="background: #0066cc; color: white; padding: 12px 30px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
          Reset Password
        </a>
      </div>
      <p style="color: #666; font-size: 14px;">If you didn't request this, you can safely ignore this email.</p>
      <p style="color: #666; font-size: 14px;">If the button doesn't work, copy and paste this link into your browser:</p>
      <p style="color: #0066cc; font-size: 12px; word-break: break-all;">${resetLink}</p>
      <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
      <p style="color: #999; font-size: 12px;">Cryo Calculator - Precision cryogenic transfer tool</p>
    </div>
  `;

  const payload = {
    from: "Cryo Calculator <noreply@cryocalculator.com>",
    to: [toEmail],
    subject: "Reset Your Password - Cryo Calculator",
    html: emailHtml
  };

  const options = {
    method: "post",
    contentType: "application/json",
    headers: {
      "Authorization": "Bearer " + CONFIG.RESEND_API_KEY
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(apiUrl, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();

    if (responseCode === 200 || responseCode === 201) {
      return { ok: true };
    } else {
      const errorData = JSON.parse(responseText);
      return { ok: false, error: errorData.message || "Failed to send email" };
    }
  } catch (err) {
    return { ok: false, error: String(err) };
  }
}

/**
 * Parse numeric value from Gemini OCR response
 */
function parseOcrValue_(text) {
  if (!text) return null;

  // Check for error response
  if (text.toUpperCase().includes("ERROR")) return null;

  // Try to extract VALUE=xxx format
  const valueMatch = text.match(/VALUE\s*=\s*([0-9]+(?:\.[0-9]+)?)/i);
  if (valueMatch) {
    return parseFloat(valueMatch[1]);
  }

  // Fallback: extract any number
  const numMatch = text.match(/\b([0-9]+(?:\.[0-9]+)?)\b/);
  if (numMatch) {
    return parseFloat(numMatch[1]);
  }

  return null;
}

/**
 * Parse BOTH inches and PSI values from Gemini OCR response
 * Expected format: INCHES=123\nPSI=45
 * For digital meters (Bulk Asset Monitor): INCHES=43\nPSI=MANUAL
 */
function parseOcrBothValues_(text) {
  const result = { inches: null, psi: null };
  if (!text) return result;

  const upperText = text.toUpperCase();

  // Try to extract INCHES=xxx (skip if ERROR or MANUAL)
  const inchesMatch = text.match(/INCHES\s*=\s*([0-9]+(?:\.[0-9]+)?)/i);
  if (inchesMatch && !upperText.includes("INCHES=ERROR") && !upperText.includes("INCHES=MANUAL")) {
    result.inches = parseFloat(inchesMatch[1]);
  }

  // Try to extract PSI=xxx (skip if ERROR or MANUAL)
  const psiMatch = text.match(/PSI\s*=\s*([0-9]+(?:\.[0-9]+)?)/i);
  if (psiMatch && !upperText.includes("PSI=ERROR") && !upperText.includes("PSI=MANUAL")) {
    result.psi = parseFloat(psiMatch[1]);
  }

  return result;
}

/** ====== HELPERS: SHEET IO ====== **/
function getSpreadsheet_() {
  if (CONFIG.SHEET_ID && String(CONFIG.SHEET_ID).trim()) {
    return SpreadsheetApp.openById(CONFIG.SHEET_ID);
  }
  return SpreadsheetApp.getActiveSpreadsheet();
}

function readSheetAsObjects_(sheet) {
  const values = sheet.getDataRange().getValues();
  if (!values || values.length < 1) return { headerMap: {}, rows: [] };

  const headers = values[0].map(h => String(h).trim());
  const headerMap = {};
  headers.forEach((h, i) => { headerMap[h] = i; });

  const rows = [];
  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    if (row.join("").trim() === "") continue;
    const obj = {};
    headers.forEach((h, i) => { obj[h] = row[i]; });
    rows.push(obj);
  }
  return { headerMap, rows };
}

/**
 * Appends an object to a sheet using the sheet's header row.
 * Any missing fields become blank. Extra fields are ignored unless the header includes them.
 */
function appendObjectToSheet_(sheet, obj) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
    .map(h => String(h).trim());

  // If sheet has no headers, fail loudly
  if (!headers.length || !headers[0]) {
    throw new Error(`Sheet "${sheet.getName()}" must have a header row (row 1).`);
  }

  const row = headers.map(h => (obj[h] !== undefined ? obj[h] : ""));
  sheet.appendRow(row);
}

/** ====== HELPERS: TOKEN (HMAC SIGNED) ====== **/
function signToken_(payload) {
  const header = { alg: "HS256", typ: "JWT-LITE" };
  const headerB64 = base64Url_(JSON.stringify(header));
  const payloadB64 = base64Url_(JSON.stringify(payload));
  const data = `${headerB64}.${payloadB64}`;
  const sig = hmacSha256Base64Url_(data, CONFIG.TOKEN_SECRET);
  return `${data}.${sig}`;
}

function verifyToken_(token) {
  try {
    const parts = String(token).split(".");
    if (parts.length !== 3) return { ok: false, error: "Bad token format" };

    const [hB64, pB64, sig] = parts;
    const data = `${hB64}.${pB64}`;
    const expectedSig = hmacSha256Base64Url_(data, CONFIG.TOKEN_SECRET);
    if (sig !== expectedSig) return { ok: false, error: "Invalid token signature" };

    const payloadJson = Utilities.newBlob(Utilities.base64DecodeWebSafe(pB64)).getDataAsString();
    const payload = JSON.parse(payloadJson);

    const now = Math.floor(Date.now() / 1000);
    if (payload.exp && now > payload.exp) return { ok: false, error: "Token expired" };

    return { ok: true, payload };
  } catch (err) {
    return { ok: false, error: "Token verify failed" };
  }
}

/** ====== HELPERS: HASHING / BASE64URL ====== **/
function sha256Base64_(text) {
  const bytes = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, text, Utilities.Charset.UTF_8);
  return Utilities.base64Encode(bytes);
}

function hmacSha256Base64Url_(data, secret) {
  const sigBytes = Utilities.computeHmacSha256Signature(data, secret, Utilities.Charset.UTF_8);
  return Utilities.base64EncodeWebSafe(sigBytes).replace(/=+$/g, "");
}

function base64Url_(str) {
  return Utilities.base64EncodeWebSafe(str, Utilities.Charset.UTF_8).replace(/=+$/g, "");
}

/** ====== HELPERS: REQUEST / RESPONSE ====== **/
function parseJsonBody_(e) {
  if (!e || !e.postData || !e.postData.contents) return {};
  try {
    return JSON.parse(e.postData.contents);
  } catch (err) {
    // Handle text/plain content type
    return {};
  }
}

/**
 * Returns a JSON response
 * Note: Apps Script doesn't support setHeader() on ContentService
 * CORS is handled automatically when deployed as Web App with "Anyone with the link" access
 */
function jsonResponse(obj, httpStatus) {
  const payload = Object.assign({}, obj, { status: httpStatus || 200 });

  return ContentService
    .createTextOutput(JSON.stringify(payload))
    .setMimeType(ContentService.MimeType.JSON);
}

function clampInt_(val, min, max, def) {
  const n = parseInt(val, 10);
  if (isNaN(n)) return def;
  return Math.max(min, Math.min(max, n));
}

/** ====== AUDIT LOG (OPTIONAL) ====== **/
function safeAudit_(eventType, data) {
  try {
    const ss = getSpreadsheet_();
    const sheet = ss.getSheetByName(CONFIG.SHEETS.AUDIT);
    if (!sheet) return; // optional
    const row = [
      new Date().toISOString(),
      String(eventType || ""),
      JSON.stringify(data || {})
    ];
    sheet.appendRow(row);
  } catch (e) {
    // Never block main flow due to audit failures
  }
}

/** ====== ADMIN: CREATE USER (RUN MANUALLY IN SCRIPT EDITOR) ====== **/
function adminCreateUser(email, password, role) {
  const ss = getSpreadsheet_();
  const sheet = ss.getSheetByName(CONFIG.SHEETS.USERS);
  if (!sheet) throw new Error("Missing users sheet");

  const cleanEmail = String(email || "").trim().toLowerCase();
  if (!cleanEmail) throw new Error("Email required");

  const userId = Utilities.getUuid();
  const hash = sha256Base64_(String(password || ""));
  const userRole = String(role || "user");

  // Ensure users sheet has headers matching:
  // user_id, email, password_hash, role, active, created_at
  appendObjectToSheet_(sheet, {
    user_id: userId,
    email: cleanEmail,
    password_hash: hash,
    role: userRole,
    active: true,
    created_at: new Date().toISOString()
  });

  return { user_id: userId, email: cleanEmail, role: userRole };
}

function createTestUser() {
  const result = adminCreateUser("test@example.com", "123456", "user");
  Logger.log(result);
}

function createAnotherUser() {
  const result = adminCreateUser("driver@company.com", "password123", "user");
  Logger.log(result);
}

// Required Sheet Headers (Row 1)

// Make sure each sheet has headers in row 1 (exact spelling matters).

// users
// user_id | email | password_hash | role | active | created_at

// calc_records

// Example minimal headers (add more columns if you want):

// record_id | user_id | timestamp | tank_type | full_inches | start_inches | end_inches | start_psi | end_psi | capacity | capacity_unit | gas | flow_value | timer_elapsed | result_text | source

// split_records
// record_id | user_id | timestamp | source_tank | destination | amount_scf | gas | notes | result_text | source

// reserve_records
// record_id | user_id | timestamp | reserve_amount | gas | remaining | warning_flag | result_text | source

// cryo_notes
// record_id | user_id | timestamp | gas | tank_id | start_inches | starting_psi | end_inches | ending_psi | metered_scf | meter_scale | result_text | source

// audit_log (optional)
// timestamp | event_type | data_json

// ============================================================
// DEPLOYMENT STEPS
// ============================================================

// 1. Open Google Sheet → Extensions → Apps Script

// 2. Paste this code into Code.gs (replace all existing content)

// 3. Update CONFIG at the top:
//    - TOKEN_SECRET: Change to a long random string (REQUIRED)
//    - SHEET_ID: Leave blank if script is bound to the sheet

// 4. Click Deploy → New deployment

// 5. Select "Web app" and configure:
//    - Description: "Cryo Calculator API"
//    - Execute as: Me
//    - Who has access: Anyone
//      ⚠️  MUST be "Anyone" (not "Anyone with the link") for CORS!

// 6. Click "Deploy" and authorize when prompted

// 7. Copy the Web App URL (ends with /exec)

// 8. Update API_ENDPOINT in frontend files:
//    - index.html, calculator.html, records.html, constant.js

// ============================================================
// CORS TROUBLESHOOTING
// ============================================================

// Google Apps Script does NOT support custom headers (Access-Control-Allow-Origin).
// CORS works automatically ONLY when deployed with "Anyone" access.

// If you STILL get CORS errors after deploying with "Anyone":

// SOLUTION 1: Use GET requests instead of POST (no preflight)
//   Frontend should use:
//   fetch(API_ENDPOINT + "?action=login&email=x&password=y")
//   instead of POST with JSON body

// SOLUTION 2: Use JSONP (works from any origin)
//   Add &callback=handleResponse to any request:
//   GET ?action=ping&callback=handleResponse
//   Returns: handleResponse({"ok":true,...});
//
//   Frontend code:
//   function handleResponse(data) { console.log(data); }
//   const script = document.createElement('script');
//   script.src = API_ENDPOINT + '?action=ping&callback=handleResponse';
//   document.body.appendChild(script);

// SOLUTION 3: Use a CORS proxy (for development only)
//   fetch('https://cors-anywhere.herokuapp.com/' + API_ENDPOINT, {...})

// ============================================================
// TESTING THE API
// ============================================================

// Test ping (browser or curl):
//   GET https://script.google.com/.../exec?action=ping
//   → {"ok":true,"service":"cryo-sheets-api","time":"..."}

// Test login via GET:
//   GET ?action=login&email=test@example.com&password=123456
//   → {"ok":true,"auth":{...}}

// Test with JSONP:
//   GET ?action=ping&callback=myFunc
//   → myFunc({"ok":true,...});

// ============================================================
// UPDATING THE DEPLOYMENT
// ============================================================

// After changing the code:
// 1. Deploy → Manage deployments
// 2. Click pencil icon (edit)
// 3. Version → "New version"
// 4. Click "Deploy"
// The URL stays the same.
//

